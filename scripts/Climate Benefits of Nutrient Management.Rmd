---
title: "Climate Benefits of Nutrient Management"
author: "J. Beaulieu, E. Kopits, C. Moore, B. Parthum"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    fig_caption: yes
    depth: 2
    number_sections: true
    code_folding:  hide
editor_options: 
  chunk_output_type: console
---

# Setup R
```{r message=FALSE, warning=FALSE}
# R 4.0.3
# see renv.lock for package versions
library(tidyverse) # dplyr, ggplot2,...
library(scales)
library(readxl) # read excel file readData.R
library(sf) # spatial data
library(USAboundaries) # for states map in Methods section
library(maps) # county map in 'Plots of total emission reductions per county'
library(kableExtra) # nice tables
library(MASS)
library(magrittr)
library(tigris) # county level data
library(cowplot) # multiple plots per page
library(ggiraph) # interactive county level plots
library(ggallin) # psuedo log10 transformation
library(rcartocolor) # color scales for maps
library(lubridate)
library(truncnorm)

# these libraries are needed when reading raw netCDF files,
# but this work has been done and files are written to disk, then
# read in below.  The netCDF code has been commented out.  We technically
# dont' need these libraries, but lets keep them for future reproducability.
library(ncdf4) # reading in ice data
library(ncdf4.helpers) # reading in ice data
library(pbapply) # status updates for big ice data loop

# Define local path for each user.  Will enable reading data from 
# 'Climate benefits of nutrient management' OneDrive folder maintained by Chris Moore
# 12/11/2020 moved all data into repo; no longer reading files out
# localPath <- Sys.getenv("USERPROFILE")

# This sets knitr wd to that of the Rstudio project.
knitr::opts_knit$set(
  # This should allow Rmarkdown to locate the data
  root.dir = rprojroot::find_rstudio_root_file()
)

# Print R session info
print(sessionInfo())
```

# Background

Lakes and reservoirs are sources of the greenhouse gases (GHG) methane (CH~4~), carbon dioxide (CO~2~), and nitrous oxide (N~2~O).  Emission rates (mass of GHG/unit time/unit area) tend to increase with lake nutrient and chlorophyll (chl) concentrations.  Water quality regulations that limit nutrient loading to surface waters could lead to reduced lake nutrient and chl content, thereby indirectly reducing GHG emission rates.  

In this project we combined modeled chl and nutrient concentrations for ~4000 lakes in the Chesepeake watershed under 1) psuedo current conditions,  and 2) a hypothetical future scenario where water quality regulations have reduced lake nutrient and chl concentration.  These estimates were combined with published models (DelSontro et al. 2018) that predict GHG emission rates from lake chl and nutrient concentration.  The objective of the project is to quantify the aggregate reduction in GHG emissions from the ~4000 lakes following the water quality improvement.  The reduction in GHG emissions is called the 'incremental' change.

# Methods
## Lake Model

Retired EPA researcher Bryan Milstead used the 'Northeast Lakes' model to estimate chl for lakes within the Chesapeake Bay watershed.  Chlorophyll was modeled under the 2010 and TMDLnew scenarios as defined below:

**2010** – represents an estimate of “current” load levels and uses estimated 2010 land uses, animal populations, atmospheric deposition, and point source loads (our “constant baseline” scenario for the SP study, probably a good candidate for our baseline).   

**TMDLnew** - Based on the final WIPs approved by EPA and air deposition that would meet 2020 air quality standards.

The modeled chl and nutrient concentrations are reported in ChesLakeLoadsConc.xlsx.

```{r}
chesDat <- read_excel("store/ChesLakeLoadsConc.xlsx",
                      sheet = "ChesLakeConc")

```

The model includes `r chesDat %>% nrow()` waterbodies.  Modeled chl and TP concentrations under the 2010 scenario average `r chesDat %>% summarize(meanChl = mean(Chla2010, na.rm = TRUE)*1e3) %>% pull() %>% round(1)` ug L^-1^ and `r chesDat %>% summarize(meanTP = mean(Pvv2010, na.rm = TRUE)*1e3) %>% pull() %>% round(1)` ug L^-1^, respectively, which are reasonable environmental values.  The model predicts that lake chl and TP will be reduced by `r chesDat %>% mutate(chlReduction = ((Chla2010 - ChlaTMDLnew) / Chla2010) * 100) %>% summarize(percentRed = mean(chlReduction, na.rm = TRUE)) %>% pull() %>% round(1)`% and `r chesDat %>% mutate(tpReduction = ((Pvv2010 - PvvTMDLnew) / Pvv2010) * 100) %>% summarize(percentRed = mean(tpReduction, na.rm = TRUE)) %>% pull() %>% round(1)`%, respectively, under the TMDLnew scenario. 
```{r }
chl.p.summary <- do.call(cbind, lapply(chesDat %>% dplyr::select(Chla2010, Pvv2010) %>% 
                                         mutate_all(~.*1e3), summary)) %>% # *1e3 mg/L to ug/L
  as.data.frame() %>%
  rownames_to_column(var = 'statistic') %>% 
  mutate_at(vars(contains("2010")), round, digits = 4)

chl.p.summary %>% kbl(col.names = c("statistic", "2010 chl", "2010 TP")) %>% kable_classic()
```
Each waterbody in the lake model output is uniquely identified by a 'WB_ID' value.  These values correspond to 'COMID' values in the NHDPlusV2 dataset, a spatial database of U.S. waterbodies.  Below we merge these data sets to combine the model output with other waterbody characteristics in NHDPlusV2, including waterbody surface areas.

``` {r results='hide', warning = FALSE, message = FALSE}
# 50 seconds
nhdSf <- st_read(dsn = "store/NHDPlusV21_National_Seamless_Flattened_Lower48.gdb",
                 layer = "NHDWaterbody") %>%
  dplyr::select(COMID, FDATE, RESOLUTION, # note, no OBJECTID when read with sf
                GNIS_ID, GNIS_NAME, AREASQKM, 
                ELEVATION, REACHCODE, FTYPE, FCODE,
                ONOFFNET, PurpCode, PurpDesc,
                MeanDepth, LakeVolume, MaxDepth, MeanDUsed, MeanDCode) # lakeMorpho data

st_crs(nhdSf) # 4269, NAD83
dim(nhdSf) # 448512 waterbodies
dim(chesDat) # 4247 waterbodies in Chesepeake Bay simulations

# we assume chesDat$WB_ID == nhdSf$COMID.  Are all WB_ID in NHD?
chesDat %>% filter(!(WB_ID %in% nhdSf$COMID)) %>% nrow() # 25 waterbodies not in NHD

chesDat %>% filter(!(WB_ID %in% nhdSf$COMID)) %>% # nothing obviously wrong with values.
  dplyr::select(WB_ID) %>% print(n=Inf)

# merge datasets
dat.sf <- merge(nhdSf, chesDat, by.x = "COMID", by.y = "WB_ID", all.y = TRUE) %>% # retain all chesDat observations
  mutate(WB_ID = as.character(COMID)) %>% # restore WB_ID column for consistency with original data.  convert to character for plotting
  dplyr::select(-COMID) # remove residual COMID column

dim(dat.sf) # 4247, good, kept all data

#  All WB_ID preserved from chesDat?
sum(!(dat.sf$WB_ID %in% chesDat$WB_ID)) # all are present in chesDat
sum(!(chesDat$WB_ID %in% dat.sf$WB_ID)) # all chesDat WB_ID in dat

# how many missing AREASQKM?
dat.sf %>% filter(is.na(AREASQKM)) %>% nrow() # just the 25 identified above
dat.sf <- dat.sf %>% dplyr::filter(!is.na(AREASQKM))# remove rows without area, corrupts ice extent calcs below
dim(dat.sf) #4222, missing area deleted

#st_write(dat.sf, 'store\\study_lakes\\study_lakes.shp') ## export lake polys

dat <- sf::st_drop_geometry(dat.sf) %>% as_tibble() # sf carries a lot of overhead not needed for most calcs.  Can convert to sf later if needed.
```

```{r fig.cap = "Location of 4,222 waterbodies in Chesapeake Bay Watershed model"}
# read in chesapeake bay watershed boundary
# https://data-chesbay.opendata.arcgis.com/search?categories=boundaries
wsb <- st_read("maps/chesapeakeBayWatershed/Chesapeake_Bay_Watershed_Boundary.shp")

# read in chesapeake bay boundary
# https://data-chesbay.opendata.arcgis.com/search?categories=boundaries

cbb <- st_read("maps/Chesapeake_Bay_Shoreline_Medium_Resolution.shp")

# Map to make sure we are in correct region.
states <- us_states() %>% # get states map
  filter(name %in% c("Virginia", "Maryland", "Delaware",
                     "West Virginia", "Pennsylvania", "New York")) 

# Make a quick map.
# This seems about right.
ggplot() +
  geom_sf(data = states) +
  geom_sf(data = wsb, fill = "light blue") +
  geom_sf(data = cbb, fill = "blue", size = NA) +
  geom_sf(data = dat.sf) +
  coord_sf(crs = st_crs(5070)) # change to albers for plotting
```


##  Ice cover
```{r message=FALSE, warning=FALSE, results="hide"}
lakeCtr <- st_centroid(dat.sf) # define centroid of lake polygon
#plot(st_geometry(dat.sf)[1]) # plot one lake
#plot(st_geometry(lakeCtr)[1], add = TRUE) # overlay centroid

# netCDF file------------------------------------------
# # Commented code below used to extract and summarize ice cover data.  It writes .shp that
# # has no ice cover data for a handful of lakes.  That .shp is read into ArcGIS Pro and missing
# # values are permuted using a nearest neighbor approach.  The final filled .shp is written out
# # of ArcGIS Pro and read in below.  The code for the netCDF does not need to be rerun.

# 
# # awesome package vignette: 
# # https://cran.r-project.org/web/packages/futureheatwaves/vignettes/starting_from_netcdf.html#:~:text=You%20can%20read%20netCDF%20data,connection%20to%20a%20netCDF%20file.
# # ncdf file downloaded  from Climate Data Center
# ice <- nc_open("store/ice.cover.10year.nc") 
# 
# ice # good!  one variable with three dimensions!
# 
# lon <- ncvar_get(ice, varid = "longitude") # extract longitude
# lat <- ncvar_get(ice, varid = "latitude") # extract latitude
# summary(lon);summary(lat) # lon matches bounding box for watershed
# 
# # inspect time dimension
# ice$dim$time
# ice$dim$time$units # hours since 1900-01-01 00:00:00.0
# ice$dim$time$calendar # gregorian.  Good, consistent with base R as.Date
# 
# ice.time <- as.POSIXct(ice$dim$time$vals * 3600, # convert hours to seconds, which are basis for POSIX class (60*60=3600)
#                         origin = as.POSIXct("1900-01-01 00:00:00"), tz = "UTC") # UTC per CDS manual
# ice.time # looks good
# 
# # licd = lake ice depth see table 1 at
# # https://confluence.ecmwf.int/display/CKB/ERA5-Land%3A+data+documentation#ERA5Land:datadocumentation-Howtouselake-relatedfields
# iceU <- ncvar_get(ice, varid = "licd") # pull ice depth data.   
# 
# # This variable is in a 3 dimensional array ordered as longitude, then latitude, then time
# dim(iceU) # 71 81 1513 
# dim(lon) # 71
# dim(lat) # 81
# dim(ice.time) # 1513
# 
# {# demo
# # # demo:  pull the modeled U10 at a certain location and time step.
# # lon.index <- which.min(abs(lon - sampFrm$lon.dd83[1])) # minimal distance between grid and desired location
# # lat.index <- which.min(abs(lat - sampFrm$lat.dd83[1])) # minimal distance between grid and desired location
# # time.index <- which(ice.time == as.POSIXct("2017-07-13 12:00:00")) # hourly data available.
# # 
# # iceU[lon.index, lat.index, time.index] # -0.9, cool!
# # 
# # # demo: get and plot full time series at grid point closes to lake:
# # iceU.ts <- nc.get.var.subset.by.axes(ice, "u10",
# #                                       axis.indices = list(X = lon.index,
# #                                                           Y = lat.index))
# # dim(iceU.ts) # 1 1 2208  1 lon, 1 lat, 2208 times
# # 
# # data_frame(time = ice.time,
# #            u10 = as.vector(iceU.ts)) %>%
# #   ggplot(aes(time, u10)) +
# #   geom_line()
# }
# 
# # pull entire time series for each waterbody
# #1. calculate lon and lat indices for each row (e.g. waterbody)
# # need to project to WGS84 for lat long
# dim(lakeCtr) #4222
# dim(lon) #71
# 
# lakeCtr <- lakeCtr %>% 
#   mutate(lk.lon = st_coordinates(.)[,1],
#          lk.lat = st_coordinates(.)[,2]) %>%
#   dplyr::select(lk.lat, lk.lon, WB_ID) %>%
#   st_drop_geometry() %>%
#   rowwise() %>% # mutate by row!!!!
#   mutate(lon.index = which.min(abs(lon - lk.lon)), # index for minimum distance between target and grid longitude
#          lat.index = which.min(abs(lat - lk.lat)), # index for minimum distance between target and grid latitude
#          lon.grid = lon[lon.index], # extract lon of closest grid, not needed for calcs, just to double check map matches observed
#          lat.grid = lat[lat.index]) %>% # extract lat of closest grid, not needed for calcs, just to double check map matches observed
#   ungroup()
# 
# # double check that extracted grids are spatially matched to lake targets
# lakeCtr %>%
#   dplyr::select(lk.lon, lk.lat, lon.grid, lat.grid) %>% # yes
#   print(n=Inf)
# 
# 
# #2. split dataframe into list
# lakeCtr.l <- split(lakeCtr, seq(nrow(lakeCtr)))
# 
# 
# #3. extract ice depth time series for each waterbody and place in list element.
# # each list element is a df containing full time series of ice depth for each lake.
# # winter 2010/2011: Nov - Dec. 2010, Jan - March 2011
# # winter 2011/2012: Nov - Dec. 2011, Jan - March 2012
# # winter 2012/2013: Nov - Dec. 2012, Jan - March 2013
# # winter 2013/2014: Nov - Dec. 2013, Jan - March 2014
# # winter 2014/2015: Nov - Dec. 2014, Jan - March 2015
# # winter 2015/2016: Nov - Dec. 2015, Jan - March 2016
# # winter 2016/2017: Nov - Dec. 2016, Jan - March 2017
# # winter 2017/2018: Nov - Dec. 2017, Jan - March 2018
# # winter 2018/2019: Nov - Dec. 2018, Jan - March 2019
# # winter 2019/2020: Nov - Dec. 2019, Jan - March 2020
# 
# # 2 minutes
# lakeCtr.l.i <- pblapply(lakeCtr.l, function(x) { # pblapply produces progress bar
#   data.frame(ice = nc.get.var.subset.by.axes(ice, "licd", # extract ice cover component 
#                                              axis.indices = list(X = x$lon.index,
#                                                                  Y = x$lat.index)) %>%
#                as.vector(),
#              time = ice.time, # add time stamp (daily ice data)
#              date = as.Date(ice.time), # collapse time stamp to date
#              lk.lat = x$lk.lat, # add latitude
#              lk.lon = x$lk.lon, # add longitude
#              WB_ID = x$WB_ID) %>% # add waterbody ID
#     # filter out extra time periods that came with climate data center download.
#     dplyr::filter(date > as.Date("2010-10-01"), # exclude Jan-Mar 2010
#                   date < as.Date("2020-04-01")) %>% # exclude Nov-Dec 2020
#     #  lake ice can be fractional within a grid-box with inland water (10 cm of ice means 
#     # 100 % of a grid-box or tile is covered with ice; 0 cm of ice means 100 % of the grid-box 
#     # is covered by water; in between a linear interpolation is applied)
#     mutate(ice = ice * 100, # convert from m to cm:  
#            ice.present = ifelse(ice > 1, # thickness > 1 cm
#                                 1, # yes, ice cover
#                                 0), # else, no ice cover
#     ice.year = ifelse(time < as.Date("2011-04-01"),
#                       "2010/2011",
#                       ifelse(time > as.Date("2011-04-01") & time < as.Date("2012-04-01"),
#                              "2011/2012",
#                              ifelse(time > as.Date("2012-04-01") & time < as.Date("2013-04-01"),
#                                     "2012/2013",
#                                     ifelse(time > as.Date("2013-04-01") & time < as.Date("2014-04-01"),
#                                            "2013/2014",
#                                            ifelse(time > as.Date("2014-04-01") & time < as.Date("2015-04-01"),
#                                                   "2014/2015",
#                                                   ifelse(time > as.Date("2015-04-01") & time < as.Date("2016-04-01"),
#                                                          "2015/2016",
#                                                          ifelse(time > as.Date("2016-04-01") & time < as.Date("2017-04-01"),
#                                                                 "2016/2017",
#                                                                 ifelse(time > as.Date("2017-04-01") & time < as.Date("2018-04-01"),
#                                                                        "2017/2018",
#                                                        ifelse(time > as.Date("2018-04-01") & time < as.Date("2019-04-01"),
#                                                               "2018/2019",
#                                                   ifelse(time > as.Date("2019-04-01"),
#                                                          "2019/2020",
#                                                          "test"))))))))))) %>% # test if no match.  should be none
#     group_by(ice.year) %>%
#     summarise(day.of.ice = sum(ice.present)) %>% # this gives total days of ice per year
#     summarise(day.of.ice = mean(day.of.ice)) # average days of ice across ten years
# 
# })
# 
# lakeCtr.i <- do.call("rbind", lakeCtr.l.i) # 
# head(lakeCtr.i) # 10 year mean day of ice per row
# dim(lakeCtr.i) # 4222, 1
# names(lakeCtr.i) # day.of.ice
# names(lakeCtr) 
# 
# # convert to sf object
# lakeCtr.sf <- cbind(lakeCtr, lakeCtr.i) %>%
#   st_as_sf(coords = c("lk.lon", "lk.lat"), crs = 4269)
# 
# # 165 lakes missing ice data?
# lakeCtr.sf %>% dplyr::filter(is.na(day.of.ice))
# 
# # Prepare to write to .shp.  will fill missing values with nearest neighbor values
# # in ArcGIS Pro.
# lakeCtr_sf <- lakeCtr.sf %>% 
#   rename_all(function(x) gsub("\\.", "_", x)) %>% # replace . with _
#   # .shp replaces NA with 0!  To avoid this, I replaced all NA with -9999 as flag to screen in GIS (see below).
#   # In GIS, convert .shp to .gdb, select all -9999 values, use field calculator
#   # to set to 'None', then use 'Fill Missing Values" tool (K (5) nearest neighbors).
#   # finally, use 'Spatial Join' in GIS to merge filled values with original file.
#   mutate(day_of_ice = replace(day_of_ice, is.na(day_of_ice), -9999)) 
# 
# # write .shp
# # st_write(lakeCtr_sf, "output/iceCover.shp", delete_layer = TRUE)
# 
# # Can't get .gpkg to work?  File not readable in ArcGIS?
# # st_write(obj = lakeCtr_sf,
# #          dsn = "output/iceCover.gpkg",
# #          layer = "ice_cover",
# #          append = FALSE,
# #          driver = "GPKG")
# # st_layers("output/iceCover.gpkg")

# read in file with missing values filled in--------------------
iceCover <- st_read("output/iceCover.gdb", layer = "iceCoverFill") %>%
  rename(day_of_ice_filled = DAY_OF_ICE_1) %>%
  dplyr::select(WB_ID, day_of_ice_filled)

# no missing values!
iceCover %>% dplyr::filter(is.na(day_of_ice_filled))
names(iceCover)

# merge ice cover estimates with dat
dim(dat) # 4222
dat <- inner_join(dat, st_drop_geometry(iceCover))
dim(dat) # 4222
```

Ice cover effectively eliminates the exchange of gases between lakes and the atmosphere; therefore GHG emission rates are 0 during periods of ice cover.  Duration of ice cover during the winter of 2019 - 2020 was downloaded from the ERA-5 Land data set (https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land?tab=overview) and spatially joined to the centroid of the NHD polygon for each waterbody in the watershed. Total days of ice cover range from `r min(lakeCtr$day.of.ice, na.rm = TRUE)` to `r max(lakeCtr$day.of.ice, na.rm = TRUE)`, with lakes in the northern portion of the watershed experiencing longer ice-cover duration than those in the south.
```{r message = FALSE, fig.cap = "Ice cover duration during the 2010-2020 winter for waterbodies in Chesapeake Bay Watershed model"}
ggplot(states) +
  geom_sf(data = wsb) + # 
  geom_sf(fill = NA) +
  geom_sf(data = iceCover, aes(color = day_of_ice_filled)) +
  coord_sf(crs = st_crs(5070)) # change to albers for plotting

# ggsave("output/figures/iceCover.tiff")

```

# GHG model
DelSontro et al. (2018) present linear regression models based on literature reports of chl concentration (ug/L), TP concentration (ug/L) and areal GHG emission rates (mg CH~4~-C m^-2^ day^-1^).  The models were created on the log-log scale with a small positive offset to accommodate negative areal emission rates reported in the literature.  Below we read in the model objects.

```{r }
# Total CH4 model.  mg CH4-C m-2 d-1
# read from disk
mod.ch4 <- readRDS("store/pCh4.rds")
summary(mod.ch4) # review model

# CO2 model.  mg CO2-C m-2 d-1
mod.co2 <- readRDS("store/pCo2.rds")
summary(mod.co2) # review model

# N2O model. mg N2O-n m-2 day-1
mod.n2o <- readRDS("store/pn2o.rds")
summary(mod.n2o) # review model
```

The models predict emission rates as log10(emission rate + positive offset) with the emission rate in units of mg CH~4~-C m^-2^ day^-1^, mg CO~2~-C m^-2^ day^-1^, or mg N~2~O-N m^-2^ day^-1^.  Predictions are back transformed to linear space and converted from mg of C or N, to mass of CH~4~, CO~2~, or N~2~O via helper functions.
```{r}
# little function to get CH4 in desired units
pCh4 <- function(x) { # x is output from above model which predicts log10(CH4-C +1)  (mg CH4-C m-2 d-1)
  mgCh4c <- 10^(x) - 1 # unlog, then subtract 1
  mgCh4 <- mgCh4c * (16/12) # mg CH4-C -> mg CH4
  return(mgCh4)
}

# little function to get CO2 in desired units
pCo2 <- function(x) { # x is output from above model which predicts log10(CH4-C +1)  (mg CO2-C m-2 d-1)
  mgCo2c <- 10^(x) - 43 # unlog, then subtract 43
  mgCo2 <- mgCo2c * (44/12) # mg CO2-C -> mg CO2
  return(mgCo2)
}

# little function to get N2O in desired units
pN2o <- function(x) { # x is output from above model which predicts log10(N2O-N)  (mg N2O-N m-2 d-1)
  mgN2on <- 10^(x) - 0.25 # unlog, then subtract 0.25
  mgN2o <- mgN2on * (44/14) # mg N2O-N -> mg N2O
  return(mgN2o)
}
```

## Inverse hyperbolic sine transformation
Bryan Parthum suggested using the inverse hyperbolic sine (IHS) transformation rather than log + positive offset. Under some conditions, the IHS transformation can lead to more accurate elasticity estimates than the log + positive offset transformation (Bellamare and Wichman 2020).  Here we use the data and CH~4~ model structure from DelSontro et al, but apply the IHS transformation rather than the log + positive offset.  Both models identify chlorophyll as a highly significant predictor and have similar coefficient of determination values.
```{r}
# Define transformation
ihs <- function(x) {
  y <- log(x + sqrt(x ^ 2 + 1))
  return(y)
}

# Inverse of IHS transformation
hs <- function(x) {
  y <- 0.5*exp(-x)*(exp(2*x)-1)
  return(y)
}

# load data for DelSontro et al CH4 model
allFlux <- read.table("store/allFlux.txt", 
                      header = TRUE, as.is = TRUE)

# new model with ihs transformation
mod.ch4.ihs <- lm(ihs(mg.CH4.C.m.2.d.1.Diffusive...Ebullitive) ~ ihs(Chlorophyll.a..ug.L.),
                  data = allFlux)

# compare models
summary(mod.ch4) # DelSontro model
summary(mod.ch4.ihs) # ihs model
```

Residuals from both models are approximately normally distributed and homoscedastic.
```{r}
ihs.log <- tibble(resid = c(resid(mod.ch4.ihs), resid(mod.ch4)), # model residuals
                  chl = c(mod.ch4.ihs$model$'ihs(Chlorophyll.a..ug.L.)', # ihs transformed chl
                          mod.ch4$model$`log10(Chlorophyll.a..ug.L.)`), # log transformed chl
                  model = c(rep("ihs", length(resid(mod.ch4.ihs))), # labels
                            rep("log", length(resid(mod.ch4))))) # labels

# homoscedasticity
ggplot(ihs.log, aes(chl, resid)) + 
  geom_point() + 
  facet_wrap(~model, scales = "free")

# normality
ggplot(ihs.log, aes(x = resid)) +
  geom_density() +
  facet_wrap(~model, scales = "free")
```

When back transformed to linear space, the model predictions are very similar up to approximately 150 mg CH4-C m-2 day-1.  Beyond that threshold, the ihs model predicts higher emission rates than the log-log model.
```{r}
# compare predictions
preds <- tibble(log.preds = predict(mod.ch4, 
                                    newdata = list(Chlorophyll.a..ug.L. = 1:100)), #75th percentile of ches chl is 36.6
                ihs.preds = predict(mod.ch4.ihs, 
                                    newdata = list(Chlorophyll.a..ug.L. = 1:100))) %>%#75th percentile of ches chl is 36.6
  mutate(log.preds = 10^(log.preds) - 1,
         ihs.preds = hs(ihs.preds))

ggplot(preds, aes(log.preds, ihs.preds)) +
  geom_point() + 
  geom_abline(slope = 1, intercept = 0) +
  xlab("CH4 emission rate (mg CH4-C m-2 day-1)\n predicted from log-log model") +
  ylab("CH4 emission rate (mg CH4-C m-2 day-1)\n predicted from ihs model") +
  ggtitle("Predictions from log-log model and ihs model")
```

# Upscaling
## GHG Emissions and Uncertainty Estimates

We use the DelSontro et al. (2018) models to predict areal GHG emission rates (mg GHG m^-2^ day^-1^) for each waterbody under the 2010 and TMDLnew scenarios.  Uncertainty was estimated using two approaches.  

### Predict mean areal emission rates (mg GHG m^-2^ day^-1^) and 95% confidence interval 
In the first approach, we calculate the 95% confidence interval of the model prediction using the 'interval' argument in the predict() function.  This results in a prediction of the mean areal emission rate, lower 2.5 percentile, and upper 97.5 percentile for each waterbody. 

```{r}
dat <- dat %>% 
  mutate(ChlaDiff = Chla2010 - ChlaTMDLnew , # policy effect on chla
         PvvDiff = Pvv2010 - PvvTMDLnew,  # policy effect on P
         
         # CH4
         # 2010 emissions
         ch42010 = predict(mod.ch4, # kettlebell model.  predicts log10(mgCH4-c m-2 d-1 + 1)
                           # model expects Chlorophyll.a..ug.L., must tell it which data to use
                           newdata = list(Chlorophyll.a..ug.L. = .$Chla2010 * 1e3),  # *1e3 because chla2010 is mg/l.
                           interval = "confidence")[,1] %>%
           pCh4(.), # function to convert to mg Ch4 m-2 d-1
         ch42010.lwr = predict(mod.ch4, # kettlebell model.  predicts log10(mgCH4-c m-2 d-1 + 1)
                               # model expects Chlorophyll.a..ug.L., must tell it which data to use
                               newdata = list(Chlorophyll.a..ug.L. = .$Chla2010 * 1e3),  # *1e3 because chla2010 is mg/l.
                               interval = "confidence")[,2] %>%
           pCh4(.), # function to convert to mg Ch4 m-2 d-1         
         ch42010.upr = predict(mod.ch4, # kettlebell model.  predicts log10(mgCH4-c m-2 d-1 + 1)
                               # model expects Chlorophyll.a..ug.L., must tell it which data to use
                               newdata = list(Chlorophyll.a..ug.L. = .$Chla2010 * 1e3),  # *1e3 because chla2010 is mg/l.
                               interval = "confidence")[,3] %>%
           pCh4(.), # function to convert to mg Ch4 m-2 d-1
         
         
         # TMDL emissions
         ch4TMDLnew = predict(mod.ch4, # kettlebell model.  predicts log10(mgCH4-c m-2 d-1 + 1)
                              # model expects Chlorophyll.a..ug.L., must tell it which data to use
                              newdata = list(Chlorophyll.a..ug.L. = .$ChlaTMDLnew * 1e3), # *1e3 because chla is mg/l.
                              interval = "confidence")[,1] %>%
           pCh4(.), # function to convert to mg Ch4 m-2 d-1
         ch4TMDLnew.lwr = predict(mod.ch4, # kettlebell model.  predicts log10(mgCH4-c m-2 d-1 + 1)
                                  # model expects Chlorophyll.a..ug.L., must tell it which data to use
                                  newdata = list(Chlorophyll.a..ug.L. = .$ChlaTMDLnew * 1e3), # *1e3 because chla is mg/l.
                                  interval = "confidence")[,2] %>%
           pCh4(.), # function to convert to mg Ch4 m-2 d-1
         ch4TMDLnew.upr = predict(mod.ch4, # kettlebell model.  predicts log10(mgCH4-c m-2 d-1 + 1)
                                  # model expects Chlorophyll.a..ug.L., must tell it which data to use
                                  newdata = list(Chlorophyll.a..ug.L. = .$ChlaTMDLnew * 1e3), # *1e3 because chla is mg/l.
                                  interval = "confidence")[,3] %>%
           pCh4(.), # function to convert to mg Ch4 m-2 d-1
         
         
         # CO2
         # 2010 emissions
         co22010 = predict(mod.co2, # kettlebell model.  predicts log10(mgco2-c m-2 d-1 + 43)
                           # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                           newdata = list(Surface.Area..km2. = .$AREASQKM,
                                          TP..ug.L. = .$Pvv2010 * 1e3),  # *1e3 because Pvv2010 is mg/l.
                           interval = "confidence")[,1] %>%
           pCo2(.), # function to convert to mg co2 m-2 d-1
         co22010.lwr = predict(mod.co2, # kettlebell model.  predicts log10(mgco2-c m-2 d-1 + 1)
                               # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                               newdata = list(Surface.Area..km2. = .$AREASQKM,
                                              TP..ug.L. = .$Pvv2010 * 1e3),  # *1e3 because Pvv2010 is mg/l.
                               interval = "confidence")[,2] %>%
           pCo2(.), # function to convert to mg co2 m-2 d-1         
         co22010.upr = predict(mod.co2, # kettlebell model.  predicts log10(mgco2-c m-2 d-1 + 1)
                               # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                               newdata = list(Surface.Area..km2. = .$AREASQKM,
                                              TP..ug.L. = .$Pvv2010 * 1e3),  # *1e3 because Pvv2010 is mg/l.
                               interval = "confidence")[,3] %>%
           pCo2(.), # function to convert to mg co2 m-2 d-1
         
         
         # TMDL emissions
         co2TMDLnew = predict(mod.co2, # kettlebell model.  predicts log10(mgco2-c m-2 d-1 + 1)
                              # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                              newdata = list(Surface.Area..km2. = .$AREASQKM,
                                             TP..ug.L. = .$PvvTMDLnew * 1e3),  # *1e3 because Pvv2010 is mg/l.
                              interval = "confidence")[,1] %>%
           pCo2(.), # function to convert to mg co2 m-2 d-1
         co2TMDLnew.lwr = predict(mod.co2, # kettlebell model.  predicts log10(mgco2-c m-2 d-1 + 1)
                                  # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                                  newdata = list(Surface.Area..km2. = .$AREASQKM,
                                                 TP..ug.L. = .$PvvTMDLnew * 1e3),  # *1e3 because Pvv2010 is mg/l.
                                  interval = "confidence")[,2] %>%
           pCo2(.), # function to convert to mg co2 m-2 d-1
         co2TMDLnew.upr = predict(mod.co2, # kettlebell model.  predicts log10(mgco2-c m-2 d-1 + 1)
                                  # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                                  newdata = list(Surface.Area..km2. = .$AREASQKM,
                                                 TP..ug.L. = .$PvvTMDLnew * 1e3),  # *1e3 because Pvv2010 is mg/l.
                                  interval = "confidence")[,3] %>%
           pCo2(.), # function to convert to mg co2 m-2 d-1
         
         # N2O
         # 2010 emissions
         n2o2010 = predict(mod.n2o, # kettlebell model.  predicts log10(mgn2o-c m-2 d-1 + 43)
                           # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                           newdata = list(Surface.Area..km2. = .$AREASQKM,
                                          Chlorophyll.a..ug.L. = .$Chla2010 * 1e3),  # *1e3 because chl is mg/l.
                           interval = "confidence")[,1] %>%
           pN2o(.), # function to convert to mg n2o m-2 d-1
         n2o2010.lwr = predict(mod.n2o, # kettlebell model.  predicts log10(mgn2o-c m-2 d-1 + 1)
                               # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                               newdata = list(Surface.Area..km2. = .$AREASQKM,
                                              Chlorophyll.a..ug.L. = .$Chla2010 * 1e3),  # *1e3 because chl is mg/l.
                               interval = "confidence")[,2] %>%
           pN2o(.), # function to convert to mg n2o m-2 d-1         
         n2o2010.upr = predict(mod.n2o, # kettlebell model.  predicts log10(mgn2o-c m-2 d-1 + 1)
                               # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                               newdata = list(Surface.Area..km2. = .$AREASQKM,
                                              Chlorophyll.a..ug.L. = .$Chla2010 * 1e3),  # *1e3 because chl is mg/l.
                               interval = "confidence")[,3] %>%
           pN2o(.), # function to convert to mg n2o m-2 d-1
         
         
         # TMDL emissions
         n2oTMDLnew = predict(mod.n2o, # kettlebell model.  predicts log10(mgn2o-c m-2 d-1 + 1)
                              # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                              newdata = list(Surface.Area..km2. = .$AREASQKM,
                                             Chlorophyll.a..ug.L. = .$ChlaTMDLnew * 1e3),  # *1e3 because chl is mg/l.
                              interval = "confidence")[,1] %>%
           pN2o(.), # function to convert to mg n2o m-2 d-1
         n2oTMDLnew.lwr = predict(mod.n2o, # kettlebell model.  predicts log10(mgn2o-c m-2 d-1 + 1)
                                  # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                                  newdata = list(Surface.Area..km2. = .$AREASQKM,
                                                 Chlorophyll.a..ug.L. = .$ChlaTMDLnew * 1e3),  # *1e3 because chl is mg/l.
                                  interval = "confidence")[,2] %>%
           pN2o(.), # function to convert to mg n2o m-2 d-1
         n2oTMDLnew.upr = predict(mod.n2o, # kettlebell model.  predicts log10(mgn2o-c m-2 d-1 + 1)
                                  # model expects Surface.Area..km2. and TP..ug.L., must tell it which data to use
                                  newdata = list(Surface.Area..km2. = .$AREASQKM,
                                                 Chlorophyll.a..ug.L. = .$ChlaTMDLnew * 1e3),  # *1e3 because chl is mg/l.
                                  interval = "confidence")[,3] %>%
           pN2o(.)) # function to convert to mg n2o m-2 d-1


dat[1:5,] %>% dplyr::select(WB_ID, contains("n2o")) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile N2O emission rate (mg N2O m-2 day-1) for five waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()

dat[1:5,] %>% dplyr::select(WB_ID, contains("co2")) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile CO2 emission rate (mg CO2 m-2 day-1) for five waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()

dat[1:5,] %>% dplyr::select(WB_ID, contains("ch4")) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile CH4 emission rate (mg CH4 m-2 day-1) for five waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()
```

### Upscale to mg GHG day^-1^
The next step is to convert the areal emission rates (mg GHG m^-2^ day^-1^) to a daily emission (mg GHG day^-1^) for each waterbody.  
``` {r}
dat <- dat %>% mutate(
  # CH4
  # 2010: upscale to per lake per day emissions
  ch42010.lk.d = ch42010 * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg CH4 d-1
  ch42010.lk.d.lwr = ch42010.lwr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg CH4 d-1
  ch42010.lk.d.upr = ch42010.upr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg CH4 d-1
  
  # TMDLNew: upscale to per lake per day emisions
  ch4TMDLnew.lk.d = ch4TMDLnew * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg CH4 d-1
  ch4TMDLnew.lk.d.lwr = ch4TMDLnew.lwr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg CH4 d-1
  ch4TMDLnew.lk.d.upr = ch4TMDLnew.upr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg CH4 d-1
  
  # CO2
  # 2010: upscale to per lake per day emissions
  co22010.lk.d = co22010 * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg CO2 d-1
  co22010.lk.d.lwr = co22010.lwr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg CO2 d-1
  co22010.lk.d.upr = co22010.upr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg CO2 d-1
  
  # TMDLNew: upscale to per lake per day emisions
  co2TMDLnew.lk.d = co2TMDLnew * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg CO2 d-1
  co2TMDLnew.lk.d.lwr = co2TMDLnew.lwr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg CO2 d-1
  co2TMDLnew.lk.d.upr = co2TMDLnew.upr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg CO2 d-1 
  
  # N2O
  # 2010: upscale to per lake per day emissions
  n2o2010.lk.d = n2o2010 * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg N2O d-1
  n2o2010.lk.d.lwr = n2o2010.lwr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg N2O d-1
  n2o2010.lk.d.upr = n2o2010.upr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  mg N2O d-1
  
  # TMDLNew: upscale to per lake per day emisions
  n2oTMDLnew.lk.d = n2oTMDLnew * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg N2O d-1
  n2oTMDLnew.lk.d.lwr = n2oTMDLnew.lwr * 1e6 * AREASQKM, # 1000000m2 = 1km2.  new variable in mg N2O d-1
  n2oTMDLnew.lk.d.upr = n2oTMDLnew.upr * 1e6 * AREASQKM) # 1000000m2 = 1km2.  new variable in mg N2O d-1


dat[1:5, ] %>% dplyr::select(WB_ID, matches("n2o.*lk.d")) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile daily N2O emission (mg N2O day-1) for five waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()

dat[1:5, ] %>% dplyr::select(WB_ID, matches("co2.*lk.d")) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile daily CO2 emission (mg CO2 day-1) for five waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()

dat[1:5, ] %>% dplyr::select(WB_ID, matches("ch4.*lk.d")) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile daily CH4 emission (mg CH4 day-1) for five waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()
```

### Upscale daily emissions to annual emissions (mg GHG year^-1^)
The models used to predict areal GHG emission rates (mg GHG m^-2^ day^-1^) are based on published measurements, most of which were made during the warm summer months when emission rates are expected to be greatest.  We therefore assume the predicted areal emission rates are constant during the open-water season.  During periods of ice cover (see above) areal emission rates are zero.  

```{r}
## get number of summer and winter days
warm.days = as.numeric(mdy('11.01.2020') - mdy('04.01.2020')) # emissions during 7 warm months (April 1 - Nov. 1)
cold.days = as.numeric(mdy('03.31.2021') - mdy('11.01.2020')) # 5 months of open-water winter rates

##  Winter rate
# Waldo et al In Review.  Mean rate from Nov.1 - April 1 = 10.56 mg CH4 m-2 d-1
ch4.winter <- 10.56 # mg CH4 m-2 d-1

dat.yr <- dat %>%
  dplyr::select(WB_ID, day_of_ice_filled, AREASQKM, contains("lk.d")) %>%
  # calculate CH4 
  mutate(across(contains("ch4"), function(x) {
    (x * warm.days) + # emissions during 7 warm months (April 1 - Nov. 1)
      ((ch4.winter * 1e6 * AREASQKM) * # 1000000m2 = 1km2.  mg CH4 d-1
         (cold.days-day_of_ice_filled))} # 5 months of open-water winter rates, discounted by days of ice)
  )
  ) %>%
  # calculate N2O and CO2.  No winter rate adjustment needed
  mutate(across(contains(c("co2", "n2o")), function(x) x * (365 - .$day_of_ice_filled))) %>% 
  rename_at(vars(-WB_ID, -day_of_ice_filled, -AREASQKM), function(x) gsub(".d", ".yr", x)) %>%
  dplyr::select(-AREASQKM)
```

### Sum annual emissions across all waterbodies.
We can now sum the total annual emissions (metric tons of GHG) across all waterbodies and both scenarios.
```{r}
dat.sum <- dat.yr %>% 
  dplyr::select(contains("lk.yr")) %>%
  summarize_all(sum, na.rm = TRUE) %>%
  mutate_all(~. / (1e3*1e3*1e3)) %>% # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg)
  rename_all(function(x) paste0(x, ".sum")) %>%
  rename_all(function(x) gsub("lk.", "", x))

dat.sum %>% dplyr::select(matches("n2o.*.yr")) %>%
  mutate_all(round, digits = 0) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile aggregate annual N2O emission (metric tons N2O day-1) for all waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()

dat.sum %>% dplyr::select(matches("co2.*.yr")) %>%
  mutate_all(round, digits = 0) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile aggregate annual CO2 emission (metric tons CO2 day-1) for all waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()

dat.sum %>% dplyr::select(matches("ch4.*.yr")) %>%
  mutate_all(round, digits = 0) %>%
  kbl(caption = "Mean, lower 2.5 percentile, and upper 97.5 percentile aggregate annual CH4 emission (metric tons CH4 day-1) for all waterbodies under the '2010' and 'TMDLnew' scenarios.") %>%
  kable_classic()
```

### Calculate incremental change

The 'incremental change' is defined as the difference in emissions between the '2010' and 'TMDLnew' scenarios.  The mean incremental change is simply calculated as the difference between the model predicted 'mean' values.  The upper 97.5 percentile of the incremental change can be calculated as the difference between the 2010 97.5 percentile and the TMDLnew 97.5 percentile.  The lower 2.5 percentile can be calculated as the difference between the 2010 and TMDLnew lower 2.5 percentile.
<!-- This calculation leads to very wide confidence intervals, including negative values for N~2~O and CO~2~.  This is probably not the best way to estimate uncertainty; however, the 'mean' estimates should be pretty good. -->
```{r}
dat.sum <- dat.sum %>%
  # incremental change (metric tons yr-1)
  mutate(ch4incr.yr = ch42010.yr.sum - ch4TMDLnew.yr.sum, 
         ch4incr.yr.upr = ch42010.yr.upr.sum - ch4TMDLnew.yr.upr.sum, 
         ch4incr.yr.lwr = ch42010.yr.lwr.sum - ch4TMDLnew.yr.lwr.sum,
         
         # CO2
         co2incr.yr = co22010.yr.sum - co2TMDLnew.yr.sum, 
         co2incr.yr.upr = co22010.yr.upr.sum - co2TMDLnew.yr.upr.sum, 
         co2incr.yr.lwr = co22010.yr.lwr.sum - co2TMDLnew.yr.lwr.sum,
         
         # N2O
         n2oincr.yr = n2o2010.yr.sum - n2oTMDLnew.yr.sum, 
         n2oincr.yr.upr = n2o2010.yr.upr.sum - n2oTMDLnew.yr.upr.sum, 
         n2oincr.yr.lwr = n2o2010.yr.lwr.sum - n2oTMDLnew.yr.lwr.sum) 


dat.sum %>% 
  dplyr::select(ch4incr.yr, ch4incr.yr.upr, ch4incr.yr.lwr, co2incr.yr, co2incr.yr.upr, 
                co2incr.yr.lwr, n2oincr.yr, n2oincr.yr.upr, n2oincr.yr.lwr) %>%
  mutate_at(vars(!contains("n2o", ignore.case = TRUE)), function(x) round(x, 0)) %>%
  mutate_at(vars(contains("n2o", ignore.case = TRUE)), function(x) round(x, 1))  %>%
  kbl(col.names = rep(c("mean", "upper 97.5", "lower 2.5"), 3),
      caption = "Incremental GHG (metric tons) calculated from model prediction error") %>%
  add_header_above(c("incremental CH4" = 3, "incremental CO2" = 3, "incremental N2O" = 3)) %>%
  kable_classic()
```

### Incremental change and uncertainty with bootstrapping

An alternative approach to estimating uncertainty is to bootstrap a sample from the `r dat %>% nrow()` waterbodies in the data.  This approach assumes the statistical predictions are correct, then simulates sampling error by bootstrapping across the sample.  As shown below, this generates much narrower confidence intervals than the approach utilizing the statistical prediction error.  This probably isn't the appropriate approach because we have a census of lake (e.g. perfect knowledge of the population) rather than a sample.
```{r}
# CALCULATE GHG EMISSIONS, AND INCREMENTAL CHANGES FOR GHG, CHLA, AND P-------------------

ghg <- list() # empty list to hold results
# time.i <- print(Sys.time())
for(i in 1:1e4) { # 4 minutes
  #print(i) # print status update
  tmpData <- dat.yr[sample(1:nrow(dat.yr), replace = TRUE), ] # bootstrap piece: sample with replacement
  ghg[[i]] <- tmpData %>% # assign object to element i of list
    dplyr::select("WB_ID", !contains("yr.")) # exclude the upper and lower confidence estimates
}
# time.i; print(Sys.time())

# simulated incremental GHG
simIncrGhg <- lapply(ghg, function(x) {
  # sum incremental difference across all lakes
  x %>% summarise(incrementalCh4 = (sum(ch42010.lk.yr, na.rm = TRUE) - sum(ch4TMDLnew.lk.yr, na.rm = TRUE)),
                  incrementalCo2 = (sum(co22010.lk.yr, na.rm = TRUE) - sum(co2TMDLnew.lk.yr, na.rm = TRUE)),
                  incrementalN2o = (sum(n2o2010.lk.yr, na.rm = TRUE) - sum(n2oTMDLnew.lk.yr, na.rm = TRUE))) %>%
    mutate_all(function(x) x / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg)
}) %>%
  do.call("rbind", .) %>% # collapse to tibble
  summarise(incrCh4 = mean(incrementalCh4), # mean CH4 increment across all lakes 
            incrCh4upr = quantile(incrementalCh4, 0.975), # upper 95% increment across all lakes
            incrCh4lwr = quantile(incrementalCh4, 0.025), # lower 5% increment across all lakes
            #CO2
            incrCo2 = mean(incrementalCo2), # mean CO2 increment across all lakes 
            incrCo2upr = quantile(incrementalCo2, 0.975), # upper 95% increment across all lakes
            incrCo2lwr = quantile(incrementalCo2, 0.025), # lower 5% increment across all lakes
            #N2O
            incrN2o = mean(incrementalN2o), # mean N2o increment across all lakes 
            incrN2oupr = quantile(incrementalN2o, 0.975), # upper 95% increment across all lakes
            incrN2olwr = quantile(incrementalN2o, 0.025)) # lower 5% increment across all lakes

simIncrGhg %>%
  mutate_at(vars(!contains("n2o", ignore.case = TRUE)), function(x) round(x, 0)) %>%
  mutate_at(vars(contains("n2o", ignore.case = TRUE)), function(x) round(x, 1)) %>%
  kbl(col.names = rep(c("mean", "upper 97.5", "lower 2.5"), 3),
      caption = "Incremental GHG (metric tons) calculated from bootstrapping.") %>%
  add_header_above(c("incremental CH4" = 3, "incremental CO2" = 3, "incremental N2O" = 3)) %>%
  kable_classic()
```

### Incremental change and uncertainty in model predictions using simulation (Krinsky and Robb, 1986)

An alternative approach to estimating uncertainty is to exploit the uncertainty in the model by randomly sampling from the distribution of the model coefficients using their covariance matrix to accommodate correlation within draws. We iterate this with 10,000 random draws.

<!-- Krinsky, I and A. L. Robb. 1986. “On Approximating the Statistical Properties of Elasticities.” Review of -->
<!-- Economic and Statistics 68: 715-719. -->

```{r results='hide', message=FALSE, warning=FALSE}
datKR <- inner_join(as_tibble(dat.sf), as_tibble(iceCover))
lakes <- datKR %>% dplyr::select(WB_ID,AREASQKM,day_of_ice_filled)

#####################################
################################  CH4
#####################################

## 2010 Data
dat_2010 <-  datKR %>%
  dplyr::select(Chla2010) %>%
  mutate('(Intercept)'=1, # match names in model
         Chla2010 = log10(Chla2010 * 1e3)) %>% # mg/L chl to ug/L
  rename('log10(Chlorophyll.a..ug.L.)'=Chla2010) %>% # match names in model
  relocate('(Intercept)','log10(Chlorophyll.a..ug.L.)') %>%
  as.matrix()

## TMDL Data
dat_tmdl <-  datKR %>%
  dplyr::select(ChlaTMDLnew) %>%
  mutate('(Intercept)'=1,
         ChlaTMDLnew = log10(ChlaTMDLnew * 1e3)) %>% # mg/L chl to ug/L
  rename('log10(Chlorophyll.a..ug.L.)'=ChlaTMDLnew) %>%
  relocate('(Intercept)','log10(Chlorophyll.a..ug.L.)') %>%
  as.matrix()

####  PREDICTIONS
set.seed(42)
ch4 <- replicate(1e4, {
  
  ## Distribution of coefficients 
  coefs = MASS::mvrnorm(1, mu = coef(mod.ch4), Sigma = vcov(mod.ch4))
  
  ## Predictions based on model uncertainty
  preds_2010_lakes <- cbind(lakes,
                            # %*% matrix multiplication
                            dat_2010 %*% coefs) # this produces emission rate as log10(CH4-C + offset)
  preds_tmdl_lakes <- cbind(lakes,
                            dat_tmdl %*% coefs)
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = pCh4(preds_2010_lakes$`dat_2010 %*% coefs`)) # transform according to functions above -> mg CH4 m-2 day-1
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = pCh4(preds_tmdl_lakes$`dat_tmdl %*% coefs`)) # transform according to functions above -> mg CH4 m-2 day-1
  
  ##  Winter rate
  # Waldo et al In Review.  Mean rate from Nov.1 - April 1 = 10.56 +/-11.52
  # this generates a winter emission rate for each lake based on the mean and sd
  # reported in Waldo et al.  Each lake will have a different winter rate, but 
  # the same rate will be used for 2010 and tmdl scenarios
  
  # set.seed(42)
  # ch4.winter <- rnorm(n = nrow(lakes), mean = 10.56, sd = 11.52) # mg CH4 m-2 d-1
  ## we want a truncated normal such that winter rates don't extend beyond the tails of the summer emission rates
  # set.seed(42)
  ch4.winter.truncated <- rtruncnorm(n=nrow(lakes), a=-1, b=4e3, mean=10.56, sd=11.52)
  
  ## plot histogram comparing normal to truncated normal
  # b <- min(c(ch4.winter,ch4.winter.t)) - 0.001 # Set the minimum for the breakpoints
  # e <- max(c(ch4.winter,ch4.winter.truncated)) # Set the maximum for the breakpoints
  # ax <- pretty(b:e, n = 12) # Make a neat vector for the breakpoints
  # c1 <- rgb(173,216,230,max = 255, alpha = 80, names = "lt.blue")
  # c2 <- rgb(255,192,203, max = 255, alpha = 80, names = "lt.pink")
  # hgA <- hist(ch4.winter, breaks = ax, plot = FALSE) # Save first histogram data
  # hgB <- hist(ch4.winter.truncated, breaks = ax, plot = FALSE) # Save 2nd histogram data
  # plot(hgA, col = c1) # Plot 1st histogram using a transparent color
  # plot(hgB, col = c2, add = TRUE) 
  
  ## discount winter ch4 emissions for the mass subject to methanotrophy
  ch4.prop.methantrophy <- runif(n = nrow(lakes), min = 0.01, max = 0.6) # proportion of ch4 that is subject to oxidization
  
  ## methanotrophy
  ch4.to.co2 <- runif(n = nrow(lakes), min = 0.05, max = 0.8) # proportion of ch4 that oxidizes to co2 
  
  #################################
  #################################
  ## recover lake-specific difference between 2010 and TMDL rates to modify winter rates under tmdl scenario
  tmdl.winter = preds_tmdl_lakes$preds_tmdl_lakes / preds_2010_lakes$preds_2010_lakes
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = ((preds_2010_lakes * warm.days) + (ch4.winter.truncated * (cold.days - day_of_ice_filled))) * 1e6 * AREASQKM + # 1000000m2 = 1km2.  new variable in mg CH4 d-1
                                 (ch4.winter.truncated * day_of_ice_filled * 1e6 * AREASQKM * ch4.prop.methantrophy * (1-ch4.to.co2))) ## add ch4 that remains after methanotrophy
  
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = ((preds_tmdl_lakes * warm.days) + ((ch4.winter.truncated * tmdl.winter) * (cold.days - day_of_ice_filled))) * 1e6 * AREASQKM + # 1000000m2 = 1km2.  new variable in mg CH4 d-1
                                 ((ch4.winter.truncated * tmdl.winter) * day_of_ice_filled * 1e6 * AREASQKM * ch4.prop.methantrophy * (1-ch4.to.co2))) ## add ch4 that remains after methanotrophy
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = preds_2010_lakes / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg.  
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = preds_tmdl_lakes / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg
  
  # preds_2010_lakes %<>% mutate(preds_2010_lakes = ((preds_2010_lakes * (7*30)) + # emissions during 7 warm months (April 1 - Nov. 1)
  #                                                    (ch4.winter * ((5*30)-day_of_ice_filled))) * # 5 months of open-water winter rates, discounted by days of ice
  #                                1000000 * AREASQKM, na.rm=TRUE) # 1000000m2 = 1km2.  new variable in mg CH4 d-1
  # 
  # 
  # preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = ((preds_tmdl_lakes * (7*30)) + # emissions during 7 warm months (April 1 - Nov. 1)
  #                                                    (ch4.winter * ((5*30) - day_of_ice_filled))) * # 5 months of open-water winter rates, discounted by days of ice
  #                                1000000 * AREASQKM, na.rm=TRUE) # 1000000m2 = 1km2.  new variable in mg CH4 d-1
  # 
  # 
  # preds_2010_lakes %<>% mutate(preds_2010_lakes = preds_2010_lakes / (1e3*1e3*1e3), na.rm=TRUE) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg.  
  # preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = preds_tmdl_lakes / (1e3*1e3*1e3), na.rm=TRUE) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg
  
  # ## Convert and take difference in predictions and sum across all lakes
  # sum(preds_2010_lakes$preds_2010_lakes - preds_tmdl_lakes$preds_tmdl_lakes, na.rm=TRUE)
  # 
  ## Convert and take difference in predictions and sum across all lakes and store CO2 from methanotrophy
  list(sum(preds_2010_lakes$preds_2010_lakes - preds_tmdl_lakes$preds_tmdl_lakes, na.rm=TRUE),
  (sum((ch4.winter.truncated * preds_2010_lakes$day_of_ice_filled * 1e6 * preds_2010_lakes$AREASQKM * ch4.prop.methantrophy * (ch4.to.co2) * 44/16), na.rm=TRUE) -
    sum(((ch4.winter.truncated * tmdl.winter) * preds_2010_lakes$day_of_ice_filled * 1e6 * preds_2010_lakes$AREASQKM * ch4.prop.methantrophy * (ch4.to.co2) * 44/16), na.rm=TRUE)) / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg

  ## THIS RETURNS A VECTOR OF PREDICTIONS FROM WHICH WE CAN CREATE CONFIDENCE INTERVALS
})

## extract and name relevant vectors
diff_ch4 = unlist(ch4[1,])
co2.from.ch4 = unlist(ch4[2,])

summary(diff_ch4)
summary(co2.from.ch4)

#####################################
################################  CO2
#####################################

#### PARTS 
## 2010 Data
dat_2010 <-  datKR %>%
  dplyr::select(Pvv2010,AREASQKM) %>%
  mutate('(Intercept)'=1,
         AREASQKM = log10(AREASQKM),
         TP..ug.L. = log10(Pvv2010 * 1e3), #mg/L -> ug/L
         'log10(Surface.Area..km2.):log10(TP..ug.L.)' = AREASQKM*TP..ug.L.) %>%
  rename('log10(Surface.Area..km2.)'=AREASQKM,'log10(TP..ug.L.)'=TP..ug.L.) %>%
  relocate('(Intercept)','log10(Surface.Area..km2.)','log10(TP..ug.L.)','log10(Surface.Area..km2.):log10(TP..ug.L.)') %>%
  dplyr::select(-Pvv2010) %>%
  as.matrix()

## TMDL Data
dat_tmdl <-  datKR %>%
  dplyr::select(PvvTMDLnew,AREASQKM) %>%
  mutate('(Intercept)'=1,
         AREASQKM = log10(AREASQKM),
         TP..ug.L. = log10(PvvTMDLnew * 1e3),
         'log10(Surface.Area..km2.):log10(TP..ug.L.)' = AREASQKM*TP..ug.L.) %>%
  rename('log10(Surface.Area..km2.)'=AREASQKM,'log10(TP..ug.L.)'=TP..ug.L.) %>%
  relocate('(Intercept)','log10(Surface.Area..km2.)','log10(TP..ug.L.)','log10(Surface.Area..km2.):log10(TP..ug.L.)') %>%
  dplyr::select(-PvvTMDLnew) %>%
  as.matrix()

####  PREDICTIONS
set.seed(42)
diff_co2 <- replicate(1e4, { #10000
  
  ## Distribution of coefficients 
  coefs = MASS::mvrnorm(1, mu = coef(mod.co2), Sigma = vcov(mod.co2))
  
  ## Predictions based on model uncertainty
  preds_2010_lakes <- cbind(lakes,
                            dat_2010 %*% coefs)
  preds_tmdl_lakes <- cbind(lakes,
                            dat_tmdl %*% coefs)
  
  ##  Winter rate
  # Data are mixed for CO2.  Jones et al 2016 report uptake during summer and outgassing
  # during winter for midwestern lakes.  Knoll et al reports sustained outgassing for an Ohio
  # Lake.  I think it best to assume 1) emissions during ice-cover are 0, and 2) emissions are 
  # equal to model predictions during the rest of the year.  
  
  #################################
  #################################
  preds_2010_lakes %<>% mutate(preds_2010_lakes = pCo2(preds_2010_lakes$`dat_2010 %*% coefs`)) # transform according to functions above. mg CO2 m-2 day-1
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = pCo2(preds_tmdl_lakes$`dat_tmdl %*% coefs`)) # transform according to functions above. mg CO2 m-2 day-1
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = (preds_2010_lakes * (365-day_of_ice_filled)) * # apply to open-water days
                                 1e6 * AREASQKM) # 1000000m2 = 1km2.  new variable in mg CO2 d-1
  
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = (preds_tmdl_lakes * (365-day_of_ice_filled)) * # apply to open-water days
                                 1e6 * AREASQKM) # 1000000m2 = 1km2.  new variable in mg CO2 d-1
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = preds_2010_lakes / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = preds_tmdl_lakes / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg
  
  ## Convert and take difference in predictions and sum across all lakes
  sum(preds_2010_lakes$preds_2010_lakes - preds_tmdl_lakes$preds_tmdl_lakes, na.rm=TRUE)
  
  ## THIS RETURNS A VECTOR OF PREDICTIONS FROM WHICH WE CAN CREATE CONFIDENCE INTERVALS
})
summary(diff_co2)

## co2 from methanotrophy
diff_co2 = diff_co2 + co2.from.ch4

#####################################
################################  N20
#####################################

#### PARTS 

## 2010 Data
dat_2010 <-  datKR %>%
  dplyr::select(Chla2010,AREASQKM) %>%
  mutate('(Intercept)'=1,
         AREASQKM = log10(AREASQKM),
         Chla2010 = log10(Chla2010 * 1e3)) %>% # mg L-1 -> ug L-1
  rename('log10(Surface.Area..km2.)'=AREASQKM,'log10(Chlorophyll.a..ug.L.)'=Chla2010) %>%
  relocate('(Intercept)','log10(Surface.Area..km2.)','log10(Chlorophyll.a..ug.L.)') %>%
  as.matrix()

## TMDL Data
dat_tmdl <-  datKR %>%
  dplyr::select(ChlaTMDLnew,AREASQKM) %>%
  mutate('(Intercept)'=1,
         AREASQKM = log10(AREASQKM),
         ChlaTMDLnew = log10(ChlaTMDLnew * 1e3)) %>% # mg L-1 -> ug L-1
  rename('log10(Surface.Area..km2.)'=AREASQKM,'log10(Chlorophyll.a..ug.L.)'=ChlaTMDLnew) %>%
  relocate('(Intercept)','log10(Surface.Area..km2.)','log10(Chlorophyll.a..ug.L.)') %>%
  as.matrix()


####  PREDICTIONS

set.seed(42)
diff_n2o <- replicate(1e4, {
  
  ## Distribution of coefficients 
  coefs = MASS::mvrnorm(1, mu = coef(mod.n2o), Sigma = vcov(mod.n2o))
  
  ## Predictions based on model uncertainty
  preds_2010_lakes <- cbind(lakes,
                            dat_2010 %*% coefs)
  preds_tmdl_lakes <- cbind(lakes,
                            dat_tmdl %*% coefs)
  
  # Winter rates
  # Few annual data available for N2O.  Kortelainen et al. 2020 reported peak N2O during winter in Finnish lakes,
  # but Beaulieu et al. 2010 reported peak N2O during summer in the Ohio River and negligable N2O during the
  # winter.  I think it best to assume 1) emissions during ice-cover are 0, and 2) emissions are 
  # equal to model predictions during the rest of the year.  
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = pN2o(preds_2010_lakes$`dat_2010 %*% coefs`)) # transform according to functions above. mg N2O m-2 day-1
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = pN2o(preds_tmdl_lakes$`dat_tmdl %*% coefs`)) # transform according to functions above. mg N2O m-2 day-1
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = (preds_2010_lakes * (365-day_of_ice_filled)) * # apply to open-water days 
                                 1e6 * AREASQKM, na.rm=TRUE) # 1000000m2 = 1km2.  new variable in mg N2O d-1
  
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = (preds_tmdl_lakes * (365-day_of_ice_filled)) * # apply to open-water days
                                 1e6 * AREASQKM, na.rm=TRUE) # 1000000m2 = 1km2.  new variable in mg N2O d-1
  
  preds_2010_lakes %<>% mutate(preds_2010_lakes = preds_2010_lakes / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg
  preds_tmdl_lakes %<>% mutate(preds_tmdl_lakes = preds_tmdl_lakes / (1e3*1e3*1e3)) # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg
  
  ## Convert and take difference in predictions and sum across all lakes
  sum(preds_2010_lakes$preds_2010_lakes - preds_tmdl_lakes$preds_tmdl_lakes, na.rm=TRUE)
  
  ## THIS RETURNS A VECTOR OF PREDICTIONS FROM WHICH WE CAN CREATE CONFIDENCE INTERVALS
})
summary(diff_n2o)
```

```{r}
kr_simulations <- data.frame(mean_ch4 = round(mean(diff_ch4),0),
                             uppr_ch4 = round(quantile(diff_ch4,.95),0),
                             lowr_ch4 = round(quantile(diff_ch4,.05),0),
                             mean_co2 = round(mean(diff_co2),0),
                             uppr_co2 = round(quantile(diff_co2,.95),0),
                             lowr_co2 = round(quantile(diff_co2,.05),0),
                             mean_n2o = round(mean(diff_n2o),1),
                             uppr_n2o = round(quantile(diff_n2o,.95),1),
                             lowr_n2o = round(quantile(diff_n2o,.05),1))
rownames(kr_simulations) <- c()

kr_simulations %>%
  kbl(col.names = rep(c("mean", "upper 95", "lower 5"), 3),
      caption = "Incremental GHG (metric tons) calculated from simulation (Krinsky and Robb, 1986)") %>%
  add_header_above(c("incremental CH4" = 3, "incremental CO2" = 3, "incremental N2O" = 3)) %>%
  kable_classic()
```

<!-- # Publication Figures -->
<!-- ## Set up temporary plotting data -->

<!-- ```{r eval = FALSE} -->
<!-- # Using emission rate values from my code, rather than final code produced by Bryan.  This will suffice as -->
<!-- # we sketch out possible figures.  After we arrive on final figures, I'll update with data from Bryan's code. -->

<!-- # PLOTTING CAN BE DONE WITH ACTUAL LAKE POLYGONS OR BY REPRESENTING EACH LAKE AS A POINT -->
<!-- # Create data object for plotting lake polygon -->
<!-- # merge data object with NHD to create polygon sf object -->
<!-- dat.poly <- merge(dplyr::select(nhdSf, COMID), dat, by.x = "COMID", by.y = "WB_ID", all.y = TRUE) %>% # retain all chesDat observations -->
<!--   mutate(WB_ID = as.character(COMID)) %>% # restore WB_ID column for consistency with original data.  convert to character for plotting -->
<!--   dplyr::select(-COMID) # remove residual COMID column -->

<!-- dim(dat.poly) # 4222 -->
<!-- plot(dat.poly$geometry) #test, looks good -->

<!-- # Now create object for plotting points -->
<!-- dat.pt <- st_centroid(dat.poly) -->
<!-- plot(dat.pt$geometry) -->
<!-- ``` -->


<!-- ## Plots of ice cover, chl, TP, and GHG emission rate: polygon plots -->
<!-- ```{r eval = FALSE} -->
<!-- # FIGURE OF INPUTS AND OUTPUTS FOR BASELINE -->
<!-- # Polygon plot-------- -->
<!-- # can add line below to ggplot to project to Albers for mapping, but I think looks better -->
<!-- # + coord_sf(crs = st_crs(5070)) # change to albers for plotting -->
<!-- st_crs(states) # 4326 (WGS84) -->

<!-- # ice days figure -->
<!-- p1 <- ggplot() + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(data = dat.poly, aes(color = day_of_ice_filled)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "Ice cover duration (days)") +  -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # chl figure -->
<!-- p2 <- ggplot() + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(data = dat.poly, aes(color = Chla2010)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "ChlA") +  -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # TP figure -->
<!-- p3 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = dat.poly, aes(color = Pvv2010)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "TP (mg/L)") +  -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # CH4 figure -->
<!-- p4 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = dat.poly, aes(color = ch42010)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "CH4 (mg m-2 d-1)") +  -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # CO2 figure -->
<!-- p5 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = dat.poly, aes(color = co22010)) +  -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "CO2 (mg m-2 d-1)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # N2O figure -->
<!-- p6 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = dat.poly, aes(color = n2o2010)) +  -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "N2O (mg m-2 d-1)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- cowplot::plot_grid(p1, p2, p3, p4, p5, p6, ncol = 3, nrow = 2, align = "hv") -->

<!-- ggsave(file = "output/figures/arealRatesNutrientsPoly.tiff", width = 15, height = 8, units = "in") -->
<!-- ``` -->


<!-- ## Plots of ice cover, chl, TP, and GHG emission rate: point plots -->
<!-- ```{r eval = FALSE} -->
<!-- # Point plot------------------- -->
<!-- # Extreme values causing wide range of color ramp which hides spatial pattern -->
<!-- # Play with removing extremes -->
<!-- # these extreme values come from the same site.  Makes sense since chl is calculated from P. -->
<!-- # consider chl > 0.2 as extreme value. -->
<!-- ggplot(dat.pt, aes(Chla2010, Pvv2010)) + geom_point() + scale_y_log10() + scale_x_log10() -->

<!-- # where are these extreme values located? -->
<!-- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 > 0.2))  -->


<!-- # ice days figure -->
<!-- p1 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = dat.pt, aes(color = day_of_ice_filled,  -->
<!--                              size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "Ice cover duration (days)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # chl figure  -->
<!-- # better without extreme values -->
<!-- p2 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), -->
<!--           aes(color = Chla2010)) + #, size = AREASQKM)) -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "ChlA") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # TP figure -->
<!-- p3 <- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = Pvv2010, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "TP (mg/L)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # CH4 figure -->
<!-- p4 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = ch42010, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) +  -->
<!--   labs(color = "CH4 (mg m-2 d-1)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # CO2 figure -->
<!-- p5 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = co22010, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) +  -->
<!--   labs(color = "CO2 (mg m-2 d-1)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # N2O figure -->
<!-- p6 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = n2o2010, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) +  -->
<!--   labs(color = "N2O (mg m-2 d-1)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- cowplot::plot_grid(p1, p2, p3, p4, p5, p6, ncol = 3, nrow = 2, align = "hv") -->

<!-- ggsave(file = "output/figures/arealRatesNutrientsPoint.tiff", width = 15, height = 8, units = "in") -->
<!-- ``` -->


<!-- ## Plots of difference in areal emission rates: 2010 - tmdl: point plots -->
<!-- ```{r eval = FALSE} -->
<!-- # first, lets add new fields to the data object -->
<!-- dat.pt <- dat.pt %>% mutate(ch4diff = ch42010 - ch4TMDLnew, -->
<!--                             co2diff = co22010 - co2TMDLnew, -->
<!--                             n2odiff = n2o2010 - n2oTMDLnew) -->

<!-- # st_write(dat.pt, 'store\\results\\results.shp') ## export results -->

<!-- # lets make sure the diff values make sense -->
<!-- # there appear to be some extreme values that might obscure -->
<!-- # interesting spatial patterns in the data.  -->
<!-- dat.pt %>% sf::st_drop_geometry(.) %>% -->
<!--   dplyr::select(contains("diff")) %>% -->
<!--   lapply(., function(x) summary(x)) -->

<!-- # lets look at distribution of values -->
<!-- # normal distribution with extremely long tails. -->
<!-- dat.pt %>% sf::st_drop_geometry(.) %>% -->
<!--   dplyr::select(contains("diff")) %>% -->
<!--   pivot_longer(everything()) %>% -->
<!--   ggplot(., aes(value)) +  -->
<!--   geom_density() + -->
<!--   facet_wrap(~name, scales = "free") -->

<!-- # closer inspection of negative values -->
<!-- # 75 cases where chl a increases under TMDL, increasing CH4 and N2O, and often CO2 -->
<!-- # the cases with crazy increases in chl and ch4 had very high initial chl values (122 and 720) -->
<!-- # maybe we want to omit extreme values from plots -->
<!-- dat.pt %>% sf::st_drop_geometry(.) %>% -->
<!--   filter(ch4diff < 0) %>% -->
<!--   dplyr::select(matches("TMDLnew|2010|diff")) %>% -->
<!--   dplyr::select(!matches("upr|lwr|in|out|Nvv")) %>% -->
<!--   mutate(across(contains("Chla"), ~.x*1e3)) %>% # convert to ug/L for convenience -->
<!--   mutate(across(contains("Chla"), ~round(.x, 3))) -->

<!-- # map of increased chl under TMDL, a few clusters of sites -->
<!-- ggplot(states) + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(fill = NA) + -->
<!--   geom_sf(data = filter(dat.pt, ChlaDiff < 0)) -->


<!-- # Point plot------------------- -->
<!-- # chl figure  -->
<!-- # better without extreme values -->
<!-- p2 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), -->
<!--           aes(color = ChlaDiff)) + #, size = AREASQKM)) -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "ChlA reduction (mg/L)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # TP figure -->
<!-- p3 <- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = PvvDiff, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(color = "TP reduction (mg/L)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # CH4 figure -->
<!-- p4 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = ch4diff, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) +  -->
<!--   labs(color = "CH4 reduction (mg m-2 d-1)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # CO2 figure -->
<!-- p5 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = co2diff, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) +  -->
<!--   labs(color = "CO2 reduction (mg m-2 d-1)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # N2O figure -->
<!-- p6 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = n2odiff, size = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   labs(color = "N2O reduction (mg m-2 d-1)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- cowplot::plot_grid(p2, p3, NULL, p4, p5, p6, ncol = 3, nrow = 2, align = "hv") -->

<!-- ggsave(file = "output/figures/pointDiff.tiff", width = 15, height = 8, units = "in") -->



<!-- ``` -->


<!-- ## Plots of difference in areal emission rates: 2010 - tmdl: point plots with color ramps -->
<!-- ```{r eval = FALSE} -->
<!-- # Point plot------------------- -->
<!-- # chl figure  -->
<!-- # better without extreme values -->
<!-- p2.col <- p2 + scale_color_gradientn(colors = rainbow(5)) -->
<!-- p3.col <- p3 + scale_color_gradientn(colors = rainbow(5)) -->
<!-- p4.col <- p4 + scale_color_gradientn(colors = rainbow(5)) -->
<!-- p5.col <- p5 + scale_color_carto_c(type ="diverging", palette="Earth") #rcartcolor library -->
<!-- p6.col <- p6 + scale_color_carto_c(type ="diverging", palette="Earth") -->


<!-- g <- gridExtra::grid.arrange(p2.col, p3.col, p4.col, p5.col, p6.col, ncol = 3, nrow = 2) -->

<!-- ggsave(file = "output/figures/pointDiffRainbow.tiff", g, width = 15, height = 8, units = "in") -->

<!-- ``` -->


<!-- ## Plots of total emission reductions per lake -->
<!-- ```{r eval = FALSE} -->
<!-- # convert object containing annual data to sf object -->
<!-- dat.yr.sf <- merge(nhdSf, dat.yr, by.x = "COMID", by.y = "WB_ID", all.y = TRUE) %>% # retain all dat.yr observations -->
<!--   mutate(WB_ID = as.character(COMID)) %>% # restore WB_ID column for consistency with original data.  convert to character for plotting -->
<!--   dplyr::select(-COMID) # remove residual COMID column -->

<!-- # convert to point for plotting -->
<!-- dat.yr.sf <- st_centroid(dat.yr.sf) -->

<!-- # calculate reduced emissions -->
<!-- dat.yr.sf <- dat.yr.sf %>% -->
<!--   mutate(ch4diff.MT = (ch42010.lk.yr - ch4TMDLnew.lk.yr)/(1e3*1e3*1e3), # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--          co2diff.MT = (co22010.lk.yr - co2TMDLnew.lk.yr)/(1e3*1e3*1e3), # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--          n2odiff.Kg = (n2o2010.lk.yr - n2oTMDLnew.lk.yr)/(1e3*1e3)) # mg->g, g->kg,  -->

<!-- # Cut into quantiles to better visualize spatial patterning -->
<!-- summary(dat.yr.sf$co2diff) -->
<!-- qco2 <- c("Lower 25%: < 0.57 MT/yr","25% to 50%: 0.57- 1.04 MT/yr","50% to 75%: 1.04 - 1.90 MT/yr","75% to 100%: > 1.9 MT/yr") -->

<!-- summary(dat.yr.sf$ch4diff) -->
<!-- qch4 <- c("Lower 25%: < 0.09 MT/yr","25% to 50%: 0.09-0.20 MT/yr","50% to 75%: 0.20-0.48 MT/yr","75% to 100%: > 0.48 MT/yr") -->

<!-- summary(dat.yr.sf$n2odiff) -->
<!-- qn2o <- c("Lower 25%: < 0.14 kg/yr","25% to 50%: 0.14 - 0.29 kg/yr","50% to 75%: 0.29 - 0.64 kg/yr","75% to 100%: > 0.64 MT/yr") -->

<!-- dat.yr.sf <- dat.yr.sf %>% -->
<!--   mutate(ch4diff_bin = cut(x = ch4diff.MT,  -->
<!--                            breaks = c(quantile(ch4diff.MT, probs = seq(0, 1, by = 1/4), na.rm = T)), -->
<!--                            include.lowest = TRUE,  -->
<!--                            labels = qch4), -->
<!--          co2diff_bin = cut(x = co2diff.MT,  -->
<!--                            breaks = c(quantile(co2diff.MT, probs = seq(0, 1, by = 1/4), na.rm = T)), -->
<!--                            include.lowest = TRUE,  -->
<!--                            labels = qco2), -->
<!--          n2odiff_bin = cut(x = n2odiff.Kg,  -->
<!--                            breaks = c(quantile(n2odiff.Kg, probs = seq(0, 1, by = 1/4), na.rm = T)), -->
<!--                            include.lowest = TRUE,  -->
<!--                            labels = qn2o)) -->


<!-- # CH4 -->
<!-- p1 <- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   geom_sf(data = dat.yr.sf %>% arrange(AREASQKM), # larger dots plot on top of small -->
<!--           aes(color = (ch42010.lk.yr - ch4TMDLnew.lk.yr)/(1e3*1e3*1e3), # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--               size = AREASQKM)) + -->
<!--   labs(color = expression(atop(Avoided~CH[4], ~(MT~yr^{-1}))), size = expression(Lake~size~(km^{2}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) + -->
<!--   scale_color_carto_c(type ="diverging", palette="Earth") -->

<!-- # CH4, alternative -->
<!-- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   geom_sf(data = dat.yr.sf %>% arrange(AREASQKM), # larger dots plot on top of small -->
<!--           aes(color = ch4diff_bin)) +  #size = AREASQKM -->
<!--   labs(color = expression(atop(Reduced~CH[4], ~(MT~yr^{-1}))), size = expression(Lake~size~(km^{2}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) + -->
<!--   scale_color_carto_d(type ="diverging", palette="Earth") -->

<!-- ggsave(file = "output/figures/ch4PointIncremental.tiff", width = 6, height = 5, units = "in") -->



<!-- # CO2 -->
<!-- p2 <- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   geom_sf(data = dat.yr.sf %>% arrange(AREASQKM), # larger dots plot on top of small -->
<!--           aes(color = (co22010.lk.yr - co2TMDLnew.lk.yr)/(1e3*1e3*1e3), # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--               size = AREASQKM)) + -->
<!--   labs(color = expression(atop(Avoided~CO[2], ~(MT~yr^{-1}))), size = expression(Lake~size~(km^{2}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # CO2 alternative -->
<!-- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   geom_sf(data = dat.yr.sf %>% arrange(AREASQKM), # larger dots plot on top of small -->
<!--           aes(color = co2diff_bin)) + #  size = AREASQKM -->
<!--   labs(color = expression(atop(Reduced~CO[2], ~(MT~yr^{-1}))), size = expression(Lake~size~(km^{2}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) + -->
<!--   scale_color_carto_d(type ="diverging", palette="Earth") -->

<!-- # N2O -->
<!-- p3 <- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   geom_sf(data = dat.yr.sf %>% arrange(AREASQKM), # larger dots plot on top of small -->
<!--           aes(color = (n2o2010.lk.yr - n2oTMDLnew.lk.yr)/(1e3*1e3), # -->
<!--               size = AREASQKM)) + -->
<!--   labs(color = expression(atop(Avoided~N[2]*O, ~(kg~yr^{-1}))), size = expression(Lake~size~(km^{2}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # N2O alternative -->
<!-- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) +  -->
<!--   geom_sf(data = dat.yr.sf %>% arrange(AREASQKM), # larger dots plot on top of small -->
<!--           aes(color = n2odiff_bin)) + # size = AREASQKM -->
<!--   labs(color = expression(atop(Avoided~N[2]*O, ~(kg~yr^{-1}))), size = expression(Lake~size~(km^{2}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) + -->
<!--   scale_color_carto_d(type ="diverging", palette="Earth") -->


<!-- cowplot::plot_grid(p1, p2, p3, ncol = 3, nrow = 1, align = "h") -->

<!-- ggsave(file = "output/figures/pointIncremental.tiff", width = 15, height = 5, units = "in") -->
<!-- ``` -->

<!-- ## Plots of total emission reductions per county -->
<!-- ```{r eval = FALSE} -->
<!-- cnty.us.tigris <- tigris::counties(state = c("Virginia", "Maryland", "Delaware", -->
<!--                                              "West Virginia", "Pennsylvania", "New York")) %>% -->
<!--   st_transform(crs = st_crs(wsb)) -->
<!-- st_crs(cnty.us.tigris) # 4326, WGS84 -->

<!-- st_crs(cnty.us.tigris) == st_crs(wsb) #TRUE -->

<!-- # clip county to Chesapeake watershed -->
<!-- cnty <- sf::st_intersection(x = cnty.us.tigris, y = wsb) # not working -->
<!-- st_crs(cnty) -->

<!-- # add county info to points -->
<!-- # but, first, add chl and TP to points -->
<!-- dat.yr.sf <- merge(dat.yr.sf,  -->
<!--                    dplyr::select(chesDat, WB_ID, Pvv2010, Chla2010)) # naive merge on WB_ID -->

<!-- # need to project cnty to dat.pt -->
<!-- cnty <- st_transform(cnty, crs = st_crs(dat.yr.sf)) -->
<!-- dat.yr.sf <- sf::st_intersection(x = dat.yr.sf, y = cnty) # this adds cty to points -->

<!-- # calculate increment by lake -->
<!-- dat.yr.sf <- dat.yr.sf %>% -->
<!--   mutate(ch42010.lk.yr.diff = ch42010.lk.yr - ch4TMDLnew.lk.yr, -->
<!--          co22010.lk.yr.diff = co22010.lk.yr - co2TMDLnew.lk.yr, -->
<!--          n2o2010.lk.yr.diff = n2o2010.lk.yr - n2oTMDLnew.lk.yr) -->

<!-- # aggregate incremental emissions and lake area by county -->
<!-- dat.yr.sf.agg <- dat.yr.sf %>% -->
<!--   group_by(STATEFP, COUNTYFP) %>% # unique cnty within state -->
<!--   summarise(across(matches("diff|AREASQKM"), sum), -->
<!--             meanTP = mean(Pvv2010), -->
<!--             meanChla = mean(Chla2010)) -->

<!-- ggplot(dat.yr.sf.agg) + geom_point(aes(AREASQKM, ch42010.lk.yr.diff)) -->

<!-- # now add aggregated incremental change to cnty attributes -->
<!-- cnty.increment <- merge(cnty, dat.yr.sf.agg %>% sf::st_drop_geometry()) -->

<!-- # convert units to metric tons -->
<!-- cnty.increment <- cnty.increment %>% -->
<!--   mutate(across(contains(".lk.yr"), ~ . / (1e3*1e3*1e3))) %>% # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--   dplyr::rename_with(.cols = contains(".lk.yr"), .fn = ~ paste0(.x, ".mt")) -->




<!-- # lake area by cnty -->
<!-- p1 <- ggplot() + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(data = cnty.increment, aes(fill = AREASQKM)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(fill = "lake area (km2)") + -->
<!--   theme(legend.position = "top", -->
<!--         panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->

<!-- # # mean TP by cnty -->
<!-- # p1 <- ggplot() + -->
<!-- #   geom_sf(data = wsb) + #  -->
<!-- #   geom_sf(data = cnty.increment, aes(fill = meanTP)) + -->
<!-- #   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!-- #   labs(fill = "mean TP (mg/L)") + -->
<!-- #   theme(legend.position = "top") -->
<!-- #  -->
<!-- # # lake chla by cnty -->
<!-- # p1 <- ggplot() + -->
<!-- #   geom_sf(data = wsb) + #  -->
<!-- #   geom_sf(data = cnty.increment, aes(fill = meanChla)) + -->
<!-- #   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!-- #   labs(fill = "mean Chla (mg/L)") + -->
<!-- #   theme(legend.position = "top") -->


<!-- # CH4 reductions -->
<!-- p2 <- ggplot() + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(data = cnty.increment, aes(fill = ch42010.lk.yr.diff.mt)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(fill = "CH4 reduction (mt year-1)") + -->
<!--   theme(legend.position = "top", -->
<!--         panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # CO2 reductions -->
<!-- p3 <- ggplot() + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(data = cnty.increment, aes(fill = co22010.lk.yr.diff.mt)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(fill = "CO2 reduction (mt year-1)") + -->
<!--   theme(legend.position = "top", -->
<!--         panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- # N2O reductions -->
<!-- p4 <- ggplot() + -->
<!--   geom_sf(data = wsb) + #  -->
<!--   geom_sf(data = cnty.increment, aes(fill = n2o2010.lk.yr.diff.mt)) + -->
<!--   geom_sf(data = cbb, fill = "blue", size = NA) + -->
<!--   labs(fill = "N2O reduction (mt year-1)") + -->
<!--   theme(legend.position = "top", -->
<!--         panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.justification = c(0,1)) -->


<!-- g <- gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 4, nrow = 1) -->

<!-- ggsave(file = "figures/cntyIncremental.tiff", g, width = 15, height = 6, units = "in") -->


<!-- # Use interactive plot to identify counties with large incremental reductions -->




<!-- gg <- ggplot(cnty.increment) + -->
<!--   geom_sf_interactive(aes(fill = ch42010.lk.yr.diff.mt, tooltip = GEOID, data_id = GEOID)) -->
<!-- ggiraph::girafe(ggobj = gg) -->

<!-- dat.yr.sf %>% filter(ALAND == 2305001140) -->

<!-- ``` -->


<!-- ## CDF plots of emission rates -->
<!-- ```{r eval = FALSE} -->
<!-- # CDF PRE AND POST----------------------- -->
<!-- dat.long <- dat.pt %>% st_drop_geometry() %>%  -->
<!--   dplyr::select(Chla2010, ChlaTMDLnew,  -->
<!--                 Pvv2010, PvvTMDLnew,  -->
<!--                 ch42010, ch4TMDLnew, -->
<!--                 co22010, co2TMDLnew, -->
<!--                 n2o2010, n2oTMDLnew) %>% -->
<!--   pivot_longer(cols = everything()) -->

<!-- p1 <- ggplot(dplyr::filter(dat.long, grepl(pattern = "Chl", x = name), value < 0.2), aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ggtitle("Chlorophyll") + -->
<!--   ylab("Cumulative Percent") + -->
<!--   theme(legend.position = c(0.8, 0.4), -->
<!--         legend.title = element_blank()) -->

<!-- p2 <- ggplot(dplyr::filter(dat.long, grepl(pattern = "Pvv", x = name), value < 0.5), aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ggtitle("total phosphorus") + -->
<!--   theme(axis.title.y = element_blank(), -->
<!--         legend.position = "none") -->

<!-- p3 <- ggplot(dplyr::filter(dat.long, grepl(pattern = "ch4", x = name), value < 750), aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ggtitle("CH4 emission rate") + -->
<!--   ylab("Cumulative Percent") + -->
<!--   theme(legend.position = "none") -->

<!-- p4 <- ggplot(dplyr::filter(dat.long, grepl(pattern = "co2", x = name), value < 5000), aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ggtitle("CO2 emission rate") + -->
<!--   theme(axis.title.y = element_blank(), -->
<!--         legend.position = "none")   -->

<!-- p5 <- ggplot(dplyr::filter(dat.long, grepl(pattern = "n2o", x = name), value < 0.75), aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ggtitle("N2O emission rate") + -->
<!--   theme(axis.title.y = element_blank(), -->
<!--         legend.position = "none") -->

<!-- g <- gridExtra::grid.arrange(gridExtra::arrangeGrob(p1, p2, ncol = 3), -->
<!--                              gridExtra::arrangeGrob(p3, p4, p5, ncol = 3), -->
<!--                              nrow = 2) -->

<!-- ggsave(file = "figures/cdf.tiff", g, width = 12, height = 8, units = "in") -->

<!-- ``` -->


<!-- ## Histogram of reductions -->

<!-- ```{r eval = FALSE} -->
<!-- # prepare data -->
<!-- dat.yr.sf.all <- merge(dat.yr.sf, dat) # bring Chl, PVV, etc back into annual emission estimates -->
<!-- dim(dat.yr.sf.all) -->


<!-- # PERCENT REDUCTION------ -->

<!-- # why do we have so many sites where CH4 increased after TMDL implementation? -->
<!-- ggplot(dplyr::filter(dat.yr.sf.all, Chla2010 < 0.2), -->
<!--        aes(x = (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr)) + geom_histogram() -->

<!-- # model predicts increased chla after TMDL for these sites -->
<!-- dplyr::filter(dat.yr.sf.all, ch42010.lk.yr - ch4TMDLnew.lk.yr <0) %>% -->
<!--   dplyr::select(ch42010.lk.yr, ch4TMDLnew.lk.yr, AREASQKM, Chla2010, ChlaTMDLnew) -->


<!-- # look at figure again, but lets remove outlier sites where CH4 increased by more than a factor of 1. -->
<!-- ggplot(dplyr::filter(dat.yr.sf.all, (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr > -1), -->
<!--        aes(x = (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr * 100)) + geom_histogram() + -->
<!--   xlab("Percent reduction in annual CH4 emissions") + -->
<!--   geom_vline(aes(xintercept = 12)) -->

<!-- # percent reduction is unrelated to lake size.  That makes sense since lake size is not it -->
<!-- # GHG prediction model for CH4  -->
<!-- ggplot(dplyr::filter(dat.yr.sf.all, (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr > -1), -->
<!--        aes(x = AREASQKM, y = (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr)) +  -->
<!--   geom_point() + -->
<!--   scale_x_log10() -->


<!-- # TOTAL REDUCTION----- -->
<!-- # histogram -->
<!-- # CH4 -->
<!-- #dplyr::filter(dat.yr.sf.all, (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr > -1) -->
<!-- p.ch4 <- ggplot(dplyr::filter(dat.yr.sf.all, (ch42010.lk.yr - ch4TMDLnew.lk.yr)/ch42010.lk.yr > -1), # one value at -10 that distorts scale -->
<!--                 aes(x = (ch42010.lk.yr - ch4TMDLnew.lk.yr) / (1e3*1e3*1e3))) + # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--   geom_histogram(bins = 75) + -->
<!--   scale_x_continuous(trans = ggallin::pseudolog10_trans, breaks = c(-10, -3, 0, 3, 10, 30, 100), minor_breaks = NULL) + -->
<!--   #geom_rug(length = grid::unit(3, units = "mm")) + -->
<!--   xlab(expression(atop("Emission Reduction", ~(metric~tons~CH[4]~yr^{-1}~lake^{-1})))) + -->
<!--   theme_bw() +  -->
<!--   theme(axis.title.y = element_blank(), -->
<!--         axis.text = element_text(size = 15), -->
<!--         axis.title = element_text(size = 20)) -->


<!-- # N2O -->
<!-- p.n2o <- ggplot(dat.yr.sf.all,  -->
<!--                 aes(x = (n2o2010.lk.yr - n2oTMDLnew.lk.yr) / (1e3*1e3))) + # mg->g, g->kg) -->
<!--   geom_histogram(bins = 75) + -->
<!--   scale_x_continuous(trans = ggallin::pseudolog10_trans, breaks = c(-10, -3, 0, 3, 10, 30, 100)) + -->
<!--   xlab(expression(atop("Emission Reduction", ~(kg~N[2]*O~yr^{-1}~lake^{-1})))) + -->
<!--   theme_bw() +  -->
<!--   theme(axis.title.y = element_blank(), -->
<!--         axis.text = element_text(size = 15), -->
<!--         axis.title = element_text(size = 20)) -->

<!-- # CO2 -->
<!-- p.co2 <- ggplot(dat.yr.sf.all,  -->
<!--                 aes(x = (co22010.lk.yr - co2TMDLnew.lk.yr) / (1e3*1e3*1e3))) + # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg) -->
<!--   geom_histogram(bins = 75) + -->
<!--   scale_x_continuous(trans = ggallin::pseudolog10_trans,  -->
<!--                      breaks = c(-10, -3, 0, 3, 10, 30, 100)) +  -->
<!--   #geom_rug(length = grid::unit(3, units = "mm")) + -->
<!--   xlab(expression(atop("Emission Reduction", ~(metric~tons~CO[2]~yr^{-1}~lake^{-1})))) + -->
<!--   theme_bw() +  -->
<!--   theme(axis.title.y = element_blank(), -->
<!--         axis.text = element_text(size = 15), -->
<!--         axis.title = element_text(size = 20)) -->


<!-- g <- gridExtra::grid.arrange(p.ch4, p.co2, p.n2o, ncol = 3, nrow = 1) -->

<!-- ggsave(file = "output/figures/incremental.histogram.tiff", g, width = 15, height = 6, units = "in") -->

<!-- # What fraction have negative avoided emissions?  Higher emissions in TMDL -->
<!-- dat.yr.sf.all %>%  -->
<!--   st_drop_geometry() %>% -->
<!--   mutate(p.ch4 = (ch42010.lk.yr - ch4TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          p.n2o = (n2o2010.lk.yr - n2oTMDLnew.lk.yr) / (1e3*1e3), -->
<!--          p.co2 = (co22010.lk.yr - co2TMDLnew.lk.yr) / (1e3*1e3*1e3)) %>% -->
<!--   summarize(neg.p.ch4 = sum(hist.dat$p.ch4 < 0, na.rm = TRUE) / nrow(.), -->
<!--             neg.p.co2 = sum(hist.dat$p.co2 < 0, na.rm = TRUE) / nrow(.), -->
<!--             neg.p.n2o = sum(hist.dat$p.n2o < 0, na.rm = TRUE) / nrow(.)) -->
<!-- ``` -->

<!-- ## Avoided emissions vs environmental variables -->
<!-- ```{r eval = FALSE} -->

<!-- # scatterplot vs size, 3 gases---------------- -->
<!-- dat.yr.sf.all %>%  -->
<!--   st_drop_geometry() %>% -->
<!--   mutate(p.ch4 = (ch42010.lk.yr - ch4TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          p.n2o = (n2o2010.lk.yr - n2oTMDLnew.lk.yr) / (1e3*1e3), -->
<!--          p.co2 = (co22010.lk.yr - co2TMDLnew.lk.yr) / (1e3*1e3*1e3)) %>% -->
<!--   dplyr::select(p.ch4, p.n2o, p.co2, AREASQKM) %>% -->
<!--   pivot_longer(cols = starts_with("p.")) %>% -->
<!--   ggplot(., aes(AREASQKM, value, color = name)) + -->
<!--   scale_color_discrete(labels = c(expression(CH[4]), -->
<!--                                   expression(CO[2]), -->
<!--                                   expression(N[2]*O))) + -->
<!--   geom_point(alpha = 0.5) + -->
<!--   scale_x_continuous(trans = ggallin::pseudolog10_trans, breaks = c(0,1,2.5,5,10,20,30)) + -->
<!--   scale_y_continuous(trans = ggallin::pseudolog10_trans, breaks = c(-100,-50, -25,-10, -1, 0, 1, 10, 25, 50, 100, 150)) +  -->
<!--   ylab(expression(atop("Avoided GHG emissions per lake", ~(MT~CH[4]~yr^{-1})~~or~~(MT~CO[2]~yr^{-1})~~or~            ~(kg~N[2]*O~yr^{-1})))) + -->
<!--   xlab(expression(Lake~area~(km^{2}))) + -->
<!--   theme_bw() + -->
<!--   theme(legend.title = element_blank(), -->
<!--         legend.position = c(0.5, 0.1), -->
<!--         legend.direction = "horizontal") -->

<!-- ggsave(file = "output/figures/incremental.lake.area.tiff", width = 6, height = 5, units = "in") -->


<!-- # scatterplot vs size, CH4 only---------------- -->
<!-- dat.yr.sf.all %>%  -->
<!--   st_drop_geometry() %>% -->
<!--   mutate(p.ch4 = (ch42010.lk.yr - ch4TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          p.n2o = (n2o2010.lk.yr - n2oTMDLnew.lk.yr) / (1e3*1e3), -->
<!--          p.co2 = (co22010.lk.yr - co2TMDLnew.lk.yr) / (1e3*1e3*1e3)) %>% -->
<!--   dplyr::select(p.ch4, AREASQKM) %>% -->
<!--   ggplot(., aes(AREASQKM, p.ch4)) + -->
<!--   geom_point(alpha = 0.5) + -->
<!--   scale_x_continuous(trans = ggallin::pseudolog10_trans, breaks = c(0,1,2.5,5,10,20,30)) + -->
<!--   scale_y_continuous(trans = ggallin::pseudolog10_trans, breaks = c(-100,-50, -25,-10, -1, 0, 1, 10, 25, 50, 100, 150)) +  -->
<!--   ylab(expression(atop("Reduced emissions per lake", ~(MT~CH[4]~yr^{-1})))) + -->
<!--   xlab(expression(Lake~area~(km^{2}))) + -->
<!--   theme_bw()  -->

<!-- ggsave(file = "output/figures/incremental.ch4.lake.area.tiff", width = 6, height = 5, units = "in") -->


<!-- # Avoided GHG emissions by lake surface area bar plot---------- -->
<!-- # set up data -->
<!-- dat.bin <- dat.yr.sf.all %>%  -->
<!--   st_drop_geometry() %>% -->
<!--   mutate(p.ch4 = (ch42010.lk.yr - ch4TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          p.n2o = (n2o2010.lk.yr - n2oTMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          p.co2 = (co22010.lk.yr - co2TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          lake.bins = ifelse(AREASQKM <= 0.01, -->
<!--                             "< 0.01 km2", -->
<!--                             ifelse(AREASQKM > 0.01 & AREASQKM <= 0.1, -->
<!--                                    ">0.01 km2 & < 0.1 km2", -->
<!--                                    ifelse(AREASQKM > 0.10 & AREASQKM <= 1, -->
<!--                                           ">0.1 km2 & < 1 km2", -->
<!--                                           ifelse(AREASQKM > 1 & AREASQKM <= 10, -->
<!--                                                  ">1 km2 & < 10 km2", -->
<!--                                                  ifelse(AREASQKM > 10, -->
<!--                                                         "> 10 km2", -->
<!--                                                         "error"))))), -->
<!--          lake.bins = factor(lake.bins, levels = c("< 0.01 km2", ">0.01 km2 & < 0.1 km2", -->
<!--                                                   ">0.1 km2 & < 1 km2", ">1 km2 & < 10 km2", -->
<!--                                                   "> 10 km2"))) %>% -->

<!--   dplyr::select(p.ch4, p.n2o, p.co2, lake.bins) %>% -->
<!--   pivot_longer(cols = starts_with("p.")) %>% -->
<!--   group_by(name, lake.bins) %>% # operate by gas x lake.bin -->
<!--   summarize(total = sum(value), # total avoided -->
<!--             obs = paste0("n = ", length(value))) #lakes per group -->

<!-- # create labels for facets -->
<!-- name.labs <- as_labeller(c(p.ch4 = "CH[4]", -->
<!--                            p.co2 = "CO[2]", -->
<!--                            p.n2o = "N[2]*O"), -->
<!--                          default = label_parsed) -->


<!-- # plot -->
<!-- ggplot(dat.bin, aes(x=lake.bins, y=total)) + -->
<!--   geom_bar(position="dodge", stat="identity") + -->
<!--   facet_wrap(~name, nrow = 3, scales = "free_y", labeller = name.labs) + -->
<!--   ylab(expression(Avoided~GHG~emissions~(MT~GHG~yr^{-1}))) + -->
<!--   theme(axis.title.x = element_blank()) + -->
<!--   geom_text(aes(label = obs), vjust = -0.5, size = 3) + -->
<!--   scale_y_continuous(expand = expansion(mult = c(0.05, 0.2)))  -->


<!-- ggsave(file = "output/figures/incremental.by.lake.area.tiff", width = 10, height = 5, units = "in") -->



<!-- # lake size histogram -->
<!-- ggplot(dat.yr.sf.all, aes(x=AREASQKM)) + geom_histogram(bins = 75) + scale_x_log10() -->


<!-- # Avoided emissions by ice cover and nutrients----------------------- -->
<!-- dat.yr.sf.all <- dat.yr.sf.all %>% -->
<!--   mutate(ch4diff.MT = (ch42010.lk.yr - ch4TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          n2odiff.Kg = (n2o2010.lk.yr - n2oTMDLnew.lk.yr) / (1e3*1e3), -->
<!--          co2diff.MT = (co22010.lk.yr - co2TMDLnew.lk.yr) / (1e3*1e3*1e3), -->
<!--          day_of_ice_filled_bin = cut(x = day_of_ice_filled, breaks = 4,  -->
<!--                                      labels = c("< 28", "28 - 55", "56 - 82", ">82")))  -->

<!-- # ice cover first -->
<!-- # scatterplot, not so great -->
<!-- ggplot(dat.yr.sf.all, aes(day_of_ice_filled, ch4diff.MT)) + geom_point() + -->
<!--   scale_y_continuous(trans = ggallin::pseudolog10_trans,  -->
<!--                      breaks = c(-100,-50, -25,-10, -1, 0, 1, 10, 25, 50, 100, 150)) -->

<!-- # bar and whisker, not much better -->
<!-- ggplot(dat.yr.sf.all, aes(day_of_ice_filled_bin, ch4diff.MT)) +  -->
<!--   geom_boxplot() + -->
<!--   scale_y_continuous(trans = ggallin::pseudolog10_trans,  -->
<!--                      breaks = c(-100,-50, -25,-10, -1, 0, 1, 10, 25, 50, 100, 150), -->
<!--                      limits = c(-1, 150)) -->

<!-- # error bars for bar chart -->
<!-- library(boot) -->

<!-- # Setting the seed for  -->
<!-- # reproducability of results -->
<!-- set.seed(42) -->

<!-- # Calling the boot function with the dataset -->
<!-- # our function and no. of rounds -->
<!-- poo <- dat.yr.sf.all %>% -->
<!--   st_drop_geometry() %>% -->
<!--   group_by(day_of_ice_filled_bin) %>% -->
<!--   group_split() %>% -->
<!--   lapply(., function(x) { -->
<!--     boot.out <- boot(x, mean.fun, R = 10) -->
<!--     foo <- boot.ci(boot.out, type = "norm") -->
<!--     return(foo) -->
<!--   } -->
<!--   ) %>% -->
<!--   lapply(., function(x) { -->
<!--     temp <- x$normal[2:3] -->
<!--     foo <- data.frame(lwr = temp[1], -->
<!--                       upr = temp[2]) -->
<!--     return(foo) -->
<!--   } -->
<!--   ) %>% -->
<!--   do.call("rbind", .) -->

<!-- # bar chart, this looks ok -->
<!-- dat.yr.sf.all %>% -->
<!--   st_drop_geometry() %>% -->
<!--   group_by(day_of_ice_filled_bin) %>% -->
<!--   summarize(ch4diff.MTbyIceBin = mean(ch4diff.MT, na.rm = TRUE), -->
<!--             nobs = n()) %>% -->
<!--   cbind(., poo) %>% # bring in 95% CI -->
<!--   ggplot(., aes(day_of_ice_filled_bin, ch4diff.MTbyIceBin)) +  -->
<!--   geom_bar(stat = "identity") + -->
<!--   geom_errorbar(aes(x = day_of_ice_filled_bin, ymin = lwr, ymax = upr), width = 0.4) + -->
<!--   ylab(expression(Reduced~CH[4]~emissions~(MT~CH[4]~yr^{-1}))) + -->
<!--   xlab("Days of ice cover") -->

<!-- ggsave("output/figures/ch4ReductionByIceCoverBin.tiff", width = 4, height = 4, units = "in") -->



<!-- # more chlorophyll equates to lower reduced emissions -->
<!-- ggplot(filter(dat.yr.sf.all, Chla2010 < 0.2), aes(Chla2010, ch4diff.MT)) + geom_point() + -->
<!--   scale_y_continuous(trans = ggallin::pseudolog10_trans,  -->
<!--                      breaks = c(-100,-50, -25,-10, -1, 0, 1, 10, 25, 50, 100, 150)) -->

<!-- ggplot(filter(dat.yr.sf.all, Chla2010 < 0.2), aes(Pvv2010, ch4diff.MT)) + geom_point() + -->
<!--   scale_y_continuous(trans = ggallin::pseudolog10_trans,  -->
<!--                      breaks = c(-100,-50, -25,-10, -1, 0, 1, 10, 25, 50, 100, 150)) -->


<!-- # Emission rate reductions by nutrients -->
<!-- # Greater reduction in emission rates (mg GHG m-2 d-1) in high chl lakes -->
<!-- ggplot(filter(dat.pt, Chla2010 < 0.2), aes(Chla2010, ch4diff)) +  -->
<!--   geom_point() + -->
<!--   ylim(-10, 150) + -->
<!--   ylab(expression(atop("Reduction in areal emission rate", (mg~CH[4]~m^{-2}*~day^{-1})))) + -->
<!--   xlab(expression(Baseline~chlorophyll~a~(mu*g~L^{-1}))) + -->
<!--   theme(axis.title = element_text(size = 14)) -->

<!-- ggsave("output/figures/arealCh4ReductionByChl.tiff", width = 6, height = 5, units = "in") -->



<!-- # Reduction in emission rates (mg GHG m-2 d-1) is proportional to reduction in chl  -->
<!-- ggplot(filter(dat.pt, Chla2010 < 0.2), aes(Chla2010 - ChlaTMDLnew, ch4diff)) + geom_point() -->

<!-- # Reduction in chl is proportional to reduction to baseline chlorophyll -->
<!-- ggplot(filter(dat.pt, Chla2010 < 0.2), aes(Chla2010 - ChlaTMDLnew, Chla2010)) + geom_point() -->


<!-- ggplot(filter(dat.pt, Chla2010 < 0.2), aes(Pvv2010, ch4diff)) + geom_point() -->
<!-- ggplot(filter(dat.pt, Chla2010 < 0.2), aes(2010 - ChlaTMDLnew, ch4diffvv)) + geom_point() -->
<!-- ``` -->

<!-- ## Avoided emissions expressed in GWP -->
<!-- ```{r eval = FALSE} -->
<!-- # CH4 and N2O are more potent GHGs than CO2.  To enable comparison, the global warming potential (GWP) -->
<!-- # of CH4 and N2O emissions can be expressed relative to that of CO2.  On 100-year horizon, CH4 = 28, N2O = 265 -->

<!-- dat.gwp <- data.frame(type = rep(c("mass", "gwp"), each = 3), -->
<!--                       gas = rep(c("CH4", "CO2", "N2O"), 2), #rep(c("CH4", "CO2", "N2O"), 2) -->
<!--                       tot = c(1870, 7008, 4.7, 1870*28, 7008, 4.7*265), -->
<!--                       tot.lwr = c(1048, 5921, 2.1, 1048*28, 5921, 2.1*265), -->
<!--                       tot.upr = c(2958, 8166, 7.6, 2958*28, 8166, 7.6*265)) -->

<!-- p.mass <- ggplot(data = filter(dat.gwp, type == "mass") , aes(x=gas, y=tot)) + -->
<!--   geom_bar(stat = "identity") + -->
<!--   geom_errorbar(aes(ymin=tot.lwr, ymax=tot.upr), width=.2, -->
<!--                 position=position_dodge(.9)) + -->
<!--   scale_x_discrete(labels = c(expression(CH[4]), expression(CO[2]), expression(N[2]*O))) + -->
<!--   ylab(expression(Avoided~GHG~emissions~(MT~GHG~yr^{-1}))) + -->
<!--   theme(axis.title.x = element_blank())  -->

<!-- p.gwp <- ggplot(data = filter(dat.gwp, type == "gwp") , aes(x=gas, y=tot)) + -->
<!--   geom_bar(stat = "identity") + -->
<!--   geom_errorbar(aes(ymin=tot.lwr, ymax=tot.upr), width=.2, -->
<!--                 position=position_dodge(.9)) + -->
<!--   scale_x_discrete(labels = c(expression(CH[4]), expression(CO[2]), expression(N[2]*O))) + -->
<!--   ylab(expression(Avoided~GHG~emissions~(MT~CO[2]~equivalents~yr^{-1}))) + -->
<!--   theme(axis.title.x = element_blank()) -->

<!-- cowplot::plot_grid(p.mass, p.gwp, ncol = 2, nrow = 1, align = "hv") -->

<!-- ggsave(file = "output/figures/mass.gwp.tiff", width = 9, height = 4, units = "in") -->
<!-- ``` -->

<!-- ## NE lakes model output -->
<!-- ```{r eval=FALSE} -->
<!-- # Map of 2010 chla and TP----------------- -->
<!-- # chl figure  -->
<!-- # better without extreme values -->
<!-- library(RColorBrewer) -->
<!-- p2 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), -->
<!--           aes(color = Chla2010)) + #, size = AREASQKM)) -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) + -->
<!--   scale_x_continuous(breaks = c(-80, -78, -76)) + -->
<!--   labs(color = expression(Chl~a~(mu*g~L^{-1}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.position = "top") #legend.justification = c(0,1) -->



<!-- # TP figure -->
<!-- p3 <- ggplot() + -->
<!--   geom_sf(data = wsb) + -->
<!--   geom_sf(data = filter(dat.pt, Chla2010 < 0.2), aes(color = Pvv2010)) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) + -->
<!--   scale_x_continuous(breaks = c(-80, -78, -76)) + -->
<!--   labs(color = expression(TP~(mg~L^{-1}))) + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.position = "top") #legend.justification = c(0,1) -->

<!-- # ice days figure -->
<!-- p4 <- ggplot() + -->
<!--   geom_sf(data = wsb) +  -->
<!--   geom_sf(data = dat.pt, aes(color = day_of_ice_filled)) + -->
<!--   geom_sf(data = cbb, fill = "white", size = NA) + -->
<!--   labs(color = "Ice cover duration (days)", size = "Lake size (km2)") + -->
<!--   theme(panel.background = element_blank(), -->
<!--         panel.border = element_rect(color = "black", fill = NA), -->
<!--         legend.position = "top") -->


<!-- cowplot::plot_grid(p2, p3, p4, ncol = 3, nrow = 1, align = "hv") -->
<!-- ggsave(file = "output/figures/NElakesOutputMap.tiff", width = 10, height = 5, units = "in") -->

<!-- # CDF figures--------------- -->
<!-- # Dataframe for medians shown in plot -->
<!-- chl.summary <- dplyr::filter(dat.long, grepl(pattern = "Chl", x = name), value < 0.2) %>% -->
<!--   mutate(value = value * 1e3) %>% # mg -> ug/L -->
<!--   dplyr::select(value, name) %>% -->
<!--   group_by(name) %>% -->
<!--   summarize(md. = median(value)) -->

<!-- # default ggplot colors.  used to match text color in annotate() -->
<!-- cols.def <- hue_pal()(2) -->

<!-- p.chl <- ggplot(dplyr::filter(dat.long, grepl(pattern = "Chl", x = name), value < 0.2) %>% -->
<!--                   mutate(value = value * 1e3), # mg -> ug/L,  -->
<!--                 aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ylab("Cumulative Percent") + -->
<!--   geom_segment(data = chl.summary, aes(x=md., xend = md., y=0, yend=0.5, color = name), linetype = 2) + -->
<!--   annotate("text", label = "2010 median = 20.8", x=20.8, y = 0.25,  -->
<!--            color = cols.def[1], hjust = -0.1, vjust = 0, size = 3) + -->
<!--   annotate("text", label = "TMDL median= 16.4", x=20.8, y = 0.1,  -->
<!--            color = cols.def[2], hjust = -0.1, vjust = 0, size = 3) + -->
<!--   xlab(expression(Chl~a~(mu*g~L^{-1}))) + -->
<!--   theme(legend.position = c(0.8, 0.4), -->
<!--         legend.title = element_blank()) + -->
<!--   scale_color_discrete(labels = c("2010", "TMDL")) -->

<!-- # Dataframe for medians shown in plot -->
<!-- tp.summary <- dplyr::filter(dat.long, grepl(pattern = "Pvv", x = name), value < 0.5) %>% -->
<!--   mutate(value = value * 1e3) %>% # mg -> ug/L -->
<!--   dplyr::select(value, name) %>% -->
<!--   group_by(name) %>% -->
<!--   summarize(md. = median(value)) -->

<!-- p.tp <- ggplot(dplyr::filter(dat.long, grepl(pattern = "Pvv", x = name), value < 0.5) %>% -->
<!--                  mutate(value = value * 1e3),  -->
<!--                aes(value, color = name)) +  -->
<!--   stat_ecdf(geom="step") + -->
<!--   ylab("Cumulative Percent") + -->
<!--   geom_segment(data = tp.summary, aes(x=md., xend = md., y=0, yend=0.5, color = name), linetype = 2) + -->
<!--   annotate("text", label = "2010 median = 43.9", x=43.9, y = 0.25,  -->
<!--            color = cols.def[1], hjust = -0.1, vjust = 0, size = 3) + -->
<!--   annotate("text", label = "TMDL median= 34.6", x=43.9, y = 0.05,  -->
<!--            color = cols.def[2], hjust = -0.1, vjust = 0, size = 3) + -->
<!--   xlab(expression(TP~(mg~L^{-1}))) + -->
<!--   theme(legend.position = c(0.8, 0.4), -->
<!--         legend.title = element_blank()) + -->
<!--   scale_color_discrete(labels = c("2010", "TMDL")) -->

<!-- cowplot::plot_grid(p.chl, p.tp, ncol = 1, nrow = 2, align = "hv") -->
<!-- ggsave(file = "output/figures/NElakesOutputCDF.tiff", width = 4, height = 5.5, units = "in") -->

<!-- ``` -->

<!-- # Write data for collaborators -->
<!-- ```{r eval=FALSE} -->
<!-- # select columns of interest, convert units -->

<!-- dat.yr.sf.all %>%  -->
<!--   # select the stuff Elizabeth wanted -->
<!--   dplyr::select(WB_ID, AREASQKM, day_of_ice_filled, Pvv2010, Chla2010, ch42010.lk.yr, ch4TMDLnew.lk.yr, co22010.lk.yr,                         co2TMDLnew.lk.yr, n2o2010.lk.yr, n2oTMDLnew.lk.yr, STATEFP, COUNTYFP) %>% -->
<!--   # convert to Elizabeth's preferred units -->
<!--   mutate(across(contains("lk.yr"),  ~. / (1e3*1e3*1e3))) %>% # mg->g, g->kg, kg->Mg. 1 MG = 1 metric ton = 1000kg))) -->
<!--   # write to disk -->
<!--   write.table(., paste0("C:\\Users\\JBEAULIE\\Environmental Protection Agency (EPA)\\Moore, Chris - Climate benefits of nutrient management\\Lakes Modeling\\climateBenefitsResults", Sys.Date(), ".txt")) -->

<!-- ``` -->